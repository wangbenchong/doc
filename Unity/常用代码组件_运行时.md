# 字符串相关

## 安全代码

```c#
using System.Text;
using UnityEngine;

public class StringUtil
{
    /// <summary>
    ///自定义字符串函数公用的StringBuilder
    /// </summary>
    static StringBuilder _customSB = new StringBuilder();
    /// <summary>
    /// 共享的StringBuilder
    /// </summary>
    static StringBuilder _shareSB = new StringBuilder();
    /// <summary>
    /// 获取共享StringBuilder并事先做好数据清理
    /// </summary>
    public static StringBuilder shareSB
    {
        get
        {
            shareSB.Remove(0, _shareSB.Length);
            return _shareSB;
        }
    }

    #region Concat
    public static string Concat(string a1, string a2)
    {
        _customSB.Remove(0, _customSB.Length);
        _customSB.Append(a1);
        _customSB.Append(a2);
        return _customSB.ToString();
    }
    public static string Concat(string a1, string a2, string a3)
    {
        _customSB.Remove(0, _customSB.Length);
        _customSB.Append(a1);
        _customSB.Append(a2);
        _customSB.Append(a3);
        return _customSB.ToString();
    }
    public static string Concat(string a1, string a2, string a3, string a4)
    {
        _customSB.Remove(0, _customSB.Length);
        _customSB.Append(a1);
        _customSB.Append(a2);
        _customSB.Append(a3);
        _customSB.Append(a4);
        return _customSB.ToString();
    }
    public static string Concat(string a1, string a2, string a3, string a4, string a5)
    {
        _customSB.Remove(0, _customSB.Length);
        _customSB.Append(a1);
        _customSB.Append(a2);
        _customSB.Append(a3);
        _customSB.Append(a4);
        _customSB.Append(a5);
        return _customSB.ToString();
    }
    public static string Concat(string a1, string a2, string a3, string a4, string a5, string a6)
    {
        _customSB.Remove(0, _customSB.Length);
        _customSB.Append(a1);
        _customSB.Append(a2);
        _customSB.Append(a3);
        _customSB.Append(a4);
        _customSB.Append(a5);
        _customSB.Append(a6);
        return _customSB.ToString();
    }
    public static string Concat(string a1, string a2, string a3, string a4, string a5, string a6, string a7)
    {
        _customSB.Remove(0, _customSB.Length);
        _customSB.Append(a1);
        _customSB.Append(a2);
        _customSB.Append(a3);
        _customSB.Append(a4);
        _customSB.Append(a5);
        _customSB.Append(a6);
        _customSB.Append(a7);
        return _customSB.ToString();
    }
    #endregion //Concat
    /// <summary>
    /// 格式化字符串
    /// </summary>
    /// <param name="format"></param>
    /// <param name="args"></param>
    /// <returns></returns>
    public static string Format(string format, params object[] args)
    {
        try
        {
            _customSB.Remove(0, _customSB.Length);
            _customSB.AppendFormat(format, args);
            return _customSB.ToString();
        }
        catch
        {
            return format;
        }
    }

    /// <summary>
    /// 数字转美式字符串
    /// </summary>
    /// <param name="num"></param>
    /// <returns></returns>
    public static string Num2US(object num)
    {
        if (num is float)
            return ((float)num).ToString("n2");
        if (num is int)
            return ((int)num).ToString("n2");
        if (num is long)
            return ((long)num).ToString("n2");
        if(num is double)
            return ((double)num).ToString("n2");
        return "0";
    }
    /// <summary>
    /// NGUI颜色富文本
    /// </summary>
    /// <param name="color"></param>
    /// <param name="text"></param>
    /// <returns></returns>
    public static string NGUIColorText(Color color, string text)
    {
        return Format("[{0}]{1}[-]", ColorUtility.ToHtmlStringRGB(color), text);
    }
    /// <summary>
    /// UGUI颜色富文本
    /// </summary>
    /// <param name="color"></param>
    /// <param name="text"></param>
    /// <returns></returns>
    public static string UGUIColorText(Color color, string text)
    {
        return Format("<color=#{0}>{1}</color>", ColorUtility.ToHtmlStringRGB(color), text);
    }
}
```

## 非安全代码

VString.cs:

```c#
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

//非安全代码，需要在Project Settings/Player/Other Setting中启用"Allow 'unsafe' code"
public static class StringExtend
{
    private static volatile object lockThis = new object();

    public static string ToTempString(this int i)
    {
        lock(lockThis)
        {
            return VString.IntToString(i);
        }        
    }

    public static string ToTempString(this float f, int digits = 2)
    {
        lock (lockThis)
        {
            return VString.FloatToString(f, digits);
        }            
    }

    public static string ToTempString(this long l)
    {
        lock (lockThis)
        {
            return VString.LongToString(l);
        }
    }

    public static string ToTempStringLower(this string str)
    {
        lock (lockThis)
        {
            return VString.ToLower(str);
        }
    }

    public static string ToTempStringUpper(this string str)
    {
        lock (lockThis)
        {
            return VString.ToUpper(str);
        }
    }

    public static string ToTempSubString(this string str, int index, int count)
    {
        lock(lockThis)
        {
            return VString.ToTempSubString(str, index, count);
        }
    }



    #region 转美式数字
    public static string ToStringUS(this float f)
    {
        return StringUtil.Num2US(f);
    }
    public static string ToStringUS(this int i)
    {
        return StringUtil.Num2US(i);
    }
    public static string ToStringUS(this long i)
    {
        return StringUtil.Num2US(i);
    }
    #endregion
}





/// <summary>
/// 内容可变的字符串
/// !!!只能作为临时变量使用,绝对不可以在逻辑中存储引用,包含VString和返回的string对象
/// </summary>
public class VString
{
    private string _data;
    private int maxCount;

    private static int _internalVsIndex;
    private static VString[] _internalVSArray = new VString[]
    {
        new VString(64),
        new VString(64),
        new VString(64),
        new VString(64),
        new VString(64),
        new VString(64),
        new VString(64),
        new VString(64),
        new VString(64),
        new VString(64),
        new VString(64),
        new VString(64),
        new VString(64),
        new VString(64),
        new VString(64),
        new VString(64),
        new VString(64),
        new VString(64),
        new VString(64),
        new VString(64)
    };
    private static string[] digitalNumberArray = new string[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" };


    public VString(int maxCount = 1024)
    {
        this.maxCount = maxCount;
        _data = new string('\0', this.maxCount);
        Clear();
    }

    public string GetString()
    {
        return _data;
    }

   

    /// <summary>
    /// int转string,无GC,注意生成的string一定不能进行存贮
    /// </summary>
    /// <param name="val"></param>
    /// <returns></returns>
    public static string IntToString(int val)
    {
        return LongToString(val);
    }

    /// <summary>
    /// long转string,无GC,注意生成的string一定不能进行存贮
    /// </summary>
    /// <param name="val"></param>
    /// <returns></returns>
    public static string LongToString(long val)
    {
        if (val == 0)
        {
            return "0";
        }

        VString tempVS = GetInternalVString();        
        bool isNegative = false;
        if (val < 0)
        {
            val = -val;
            isNegative = true;
        }

        while (val != 0)
        {
            long mod = val % 10;
            val = val / 10;
            tempVS.Push(digitalNumberArray[mod]);
        }

        if (isNegative)
        {
            tempVS.Push("-");
        }

        tempVS.ReverseString();
        return tempVS.GetString();
    }

    /// <summary>
    /// float转string,无GC,注意生成的string一定不能进行存贮
    /// </summary>
    /// <param name="f"></param>
    /// <param name="digits">小数的位数</param>
    /// <returns></returns>
    public static string FloatToString(float f, int digits = 2)
    {
        bool isNegative = false;
        if (f < 0)
        {
            f = -f;
            isNegative = true;
        }

        int iPart = Mathf.FloorToInt(f);
        float fPart = f - iPart;

        VString tempVS0 = GetInternalVString();        


        if(iPart != 0)
        {
            while (iPart != 0)
            {
                long mod = iPart % 10;
                iPart = iPart / 10;
                tempVS0.Push(digitalNumberArray[mod]);
            }
        }
        else
        {
            tempVS0.Push("0");
        }

        if(isNegative)
        {
            tempVS0.Push("-");
        }
        tempVS0.ReverseString();
        

        if (digits != 0)
        {
            VString tempVS1 = GetInternalVString();            
            fPart = fPart * Mathf.Pow(10, digits);
            int iPart2 = Mathf.RoundToInt(fPart);

            int i = 0;
            while (iPart2 != 0 && i < digits)
            {
                long mod = iPart2 % 10;
                iPart2 = iPart2 / 10;
                i++;
                tempVS1.Push(digitalNumberArray[mod]);
            }
            tempVS1.ReverseString();

            tempVS0.Push(".");
            tempVS0.Push(tempVS1.GetString());
            while(i < digits)
            {
                i++;
                tempVS0.Push("0");
            }
        }
        else
        {
            tempVS0.Push(".");
            for (int i = 0; i < digits; ++i)
            {
                tempVS0.Push("0");
            }
        }
               
        return tempVS0.GetString();
    }


    /// <summary>
    /// 把一个字符串拷贝后,转换为lower case,,注意生成的string一定不能进行存贮
    /// </summary>
    /// <param name="str"></param>
    /// <returns></returns>
    public static string ToLower(string str)
    {
        if(!string.IsNullOrEmpty(str))
        {
            VString tempVS = VStringShareObject.GetShareVString();
            tempVS.Push(str);
            tempVS.ToLower();
            return tempVS.GetString();
        }
        return str;
    }

    /// <summary>
    /// 把一个字符串拷贝后,转换为upper case,,注意生成的string一定不能进行存贮
    /// </summary>
    /// <param name="str"></param>
    /// <returns></returns>
    public static string ToUpper(string str)
    {
        if (!string.IsNullOrEmpty(str))
        {
            VString tempVS = VStringShareObject.GetShareVString();
            tempVS.Push(str);
            tempVS.ToUpper();
            return tempVS.GetString();
        }
        return str;
    }

    public static string ToTempSubString(string str, int index, int count)
    {
        if(string.IsNullOrEmpty(str) || count <= 0 || index < 0)
        {
            LogHelper.LogError(VStringUtil.Concat("ToTempSubString IsNullOrEmpty ", index.ToTempString(), "/", count.ToTempString()));
            return str;
        }

        if(index + count > str.Length)
        {
            LogHelper.LogError(VStringUtil.Concat("ToTempSubString ", str, index.ToTempString(), "/", count.ToTempString()));
            return str;
        }

        VString tempVS1 = VStringShareObject.GetShareVString();
        tempVS1.Push(str);
        VString tempVS2 = VStringShareObject.GetShareVString();
        tempVS2.CopyFrom(tempVS1, index, count);
        return tempVS2.GetString();
    }


    /// <summary>
    /// 拼接两个字符串
    /// </summary>
    /// <param name="a"></param>
    /// <param name="b"></param>
    /// <param name="clear"></param>
    /// <returns></returns>
    public string Concat(string a, string b, bool clear = true)
    {
        if(clear)
        {
            Clear();
        }

        Push(a);
        Push(b);
        return _data;
    }


    
    public string Concat(string a, string b, string c, bool clear = true)
    {
        if (clear)
        {
            Clear();
        }

        Push(a);
        Push(b);
        Push(c);
        return _data;
    }
    public string Concat(string a, string b, string c, string d, bool clear = true)
    {
        if (clear)
        {
            Clear();
        }

        Push(a);
        Push(b);
        Push(c);
        Push(d);
        return _data;
    }
    public string Concat(string a, string b, string c, string d, string e, bool clear = true)
    {
        if (clear)
        {
            Clear();
        }

        Push(a);
        Push(b);
        Push(c);
        Push(d);
        Push(e);
        return _data;
    }
    public string Concat(string a, string b, string c, string d, string e, string f, bool clear = true)
    {
        if (clear)
        {
            Clear();
        }

        Push(a);
        Push(b);
        Push(c);
        Push(d);
        Push(e);
        Push(f);
        return _data;
    }
    public string Concat(string a, string b, string c, string d, string e, string f, string g, bool clear = true)
    {
        if (clear)
        {
            Clear();
        }

        Push(a);
        Push(b);
        Push(c);
        Push(d);
        Push(e);
        Push(f);
        Push(g);
        return _data;
    }
    public string Concat(string a, string b, string c, string d, string e, string f, string g, string h, bool clear = true)
    {
        if (clear)
        {
            Clear();
        }

        Push(a);
        Push(b);
        Push(c);
        Push(d);
        Push(e);
        Push(f);
        Push(g);
        Push(h);
        return _data;
    }
    public string Concat(string a, string b, string c, string d, string e, string f, string g, string h, string i, bool clear = true)
    {
        if (clear)
        {
            Clear();
        }

        Push(a);
        Push(b);
        Push(c);
        Push(d);
        Push(e);
        Push(f);
        Push(g);
        Push(h);
        Push(i);
        return _data;
    }
    public string Concat(string a, string b, string c, string d, string e, string f, string g, string h, string i, string j, bool clear = true)
    {
        if (clear)
        {
            Clear();
        }

        Push(a);
        Push(b);
        Push(c);
        Push(d);
        Push(e);
        Push(f);
        Push(g);
        Push(h);
        Push(i);
        Push(j);
        return _data;
    }


    public static bool UseShareObject(string str)
    {
        for (int i = 0; i < _internalVSArray.Length; ++i)
        {
            if (string.ReferenceEquals(str, _internalVSArray[i].GetString()))
            {
                return true;
            }
        }
        return false;
    }


    //往当前的字符串中添加字符串
    public unsafe void Push(string newStr)
    {
        if(string.IsNullOrEmpty(newStr))
        {
            return;
        }

        int copyLen = newStr.Length;
        int newLen = _data.Length + copyLen;
        if (newLen > maxCount)
        {
            copyLen = maxCount - _data.Length;
            //这个地方不使用VstringUtil.Concat避免死循环
            LogHelper.LogError(StringUtil.Concat("超过了最大添加长度 ", maxCount.ToTempString(), " ", newLen.ToTempString()));            
        }

        if(copyLen <= 0)
        {
            return;
        }

        fixed (char* src = newStr)
        {
            fixed(char* dst = _data)
            {
                UnsafeFunction.memcpyimpl((byte*)src, (byte*)(dst + _data.Length), copyLen * 2); //system.string的存储每个元素两个字节

                int* iDst = (int*)dst; 
                iDst = iDst - 1;    //字符串的长度在第一个元素的前面4个字节
                * iDst = newLen;
            }
        }
    }
    

    public unsafe void Clear()
    {
        fixed(char* p = _data)
        {           
            int* pSize = (int*)p;
            pSize = pSize - 1;
            *pSize = 0;
        }
    }

    public unsafe void CopyFrom(VString srcVstring, int startIndex, int count)
    {
        if(count > maxCount)
        {
            throw new ArgumentException(VStringUtil.Concat("copy count is larger then maxCount ", 
                count.ToTempString(), " ", maxCount.ToTempString()));
        }

        string srcStr = srcVstring.GetString();
        if (startIndex + count > srcStr.Length)
        {
            throw new ArgumentException(VStringUtil.Concat("copy count is larger then srcString len ", 
                count.ToTempString(), " ", srcStr.Length.ToTempString(), " ", startIndex.ToTempString()));
        }

        Clear();

        fixed (char* src = srcStr)
        {
            fixed (char* dst = _data)
            {
                UnsafeFunction.memcpyimpl((byte*)(src + startIndex), (byte*)dst, count * 2); //system.string的存储每个元素两个字节

                int* iDst = (int*)dst;
                iDst = iDst - 1;    //字符串的长度在第一个元素的前面4个字节
                *iDst = count;
            }
        }
    }

    public unsafe void ToLower()
    {
        int index = 0;
        int len = _data.Length;
        fixed (char* dst = _data)
        {
            while(index < len)
            {
                char tempChar = *(dst + index);
                *(dst + index) = char.ToLower(tempChar);
                ++index;
            }
        }
    }

    public unsafe void ToUpper()
    {
        int index = 0;
        int len = _data.Length;
        fixed (char* dst = _data)
        {
            while (index < len)
            {
                char tempChar = *(dst + index);
                *(dst + index) = char.ToUpper(tempChar);
                ++index;
            }
        }
    }

    //反转字符串的内容
    private unsafe string ReverseString()
    {
        int len = _data.Length;
        if(len > 0)
        {
            fixed (char* pHead = _data)
            {
                int count = len / 2;
                for (int i = 0; i < count; ++i)
                {
                    char temp = pHead[i];
                    pHead[i] = pHead[len - 1 - i];
                    pHead[len - 1 - i] = temp;
                }
            }
        }
        return _data;
    }    


    private static VString GetInternalVString()
    {
        _internalVsIndex = (_internalVsIndex + 1) % _internalVSArray.Length;
        VString vString = _internalVSArray[_internalVsIndex];
        vString.Clear();
        return vString;
    }
}
```



# 通过ScriptableObject生成asset文件

```c
using UnityEngine;
[CreateAssetMenu(menuName= "Script Objects/Sample")]
public class SamepleScriptableObject : ScriptableObject
{
    private void Awake(){}
    private void OnEnable(){}
    privaet void OnDisable(){}
    private void OnDestroy(){}
}
```

好处：

- 可在运行时修改
- 分拆数据防止prefab过大，减少同时编辑prefab的情况

# UGUI空图片

响应点击，但不可见

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof(CanvasRenderer))]
public class EmptyImageGraphic : Graphic
{
    protected EmptyImageGraphic()
    {
        useLegacyMeshGeneration = false;
    }
    protected override void OnPopulateMesh(VertexHelper m)
    {
        m.Clear();
    }
}
```

# 批量生成可复用物体

```c#
/// <summary>
/// 复制物体并填充列表
/// </summary>
/// <typeparam name="T">item的类型</typeparam>
/// <param name="parent">批量生成在哪个父节点下</param>
/// <param name="goTmp">模板（会自动掩藏）</param>
/// <param name="needCount">生成数量</param>
/// <param name="goList">记录生成item的列表</param>
/// <param name="hideGoTmp">是否隐藏模板，如不隐藏会把模板填充到列表中</param>
/// <param name="initCallback">初次生成需要做的回调</param>
public static void FillWithTempItem<T>(Transform parent, MonoBehaviour goTmp, int needCount, List<T> goList, bool hideGoTmp = true, Action<T> initCallback = null) where T : MonoBehaviour
{
    if (goList == null)
    {
        Debug.LogError("传入的列表不可为null！");
        return;
    }
    if(parent == null || goTmp == null)
    {
        return;
    }
    for(int i=goList.Count - 1;i>= 0; --i)
    {
        if(null == goList[i])
        {
            goList.RemoveAt(i);
        }
    }

    if(!hideGoTmp)
    {
        bool bContainTmp = false;
        T comTmp = (T)goTmp;
        if(comTmp != null)
        {
            bContainTmp = goList.Contains(comTmp);
            if(!bContainTmp)
            {
                goList.Insert(0, comTmp);
                if(initCallback != null)
                {
                    initCallback(comTmp);
                }
            }
        }
    }
    else
    {
#if UNITY_EDITOR
        if (!UnityEditor.PrefabUtility.IsPartOfAnyPrefab(goTmp))
#endif
            goTmp.gameObject.SetActive(false);
    }

    int GoListCount = goList.Count;
    for(int i=GoListCount; i<needCount; i++)
    {
        T item = UnityEngine.Object.Instantiate((T)goTmp, parent, false) as T;
        if(initCallback != null)
        {
            initCallback(item);
        }
        goList.Add(item);
    }
    GoListCount = goList.Count;
    for(int i=0; i<GoListCount; i++)
    {
        T item = goList[i];
        bool active = i < needCount;
        if(active)
        {
            Transform itemTra = item.transform;
            if(itemTra.parent != parent)
            {
                itemTra.SetParent(parent, false);
                itemTra.localPosition = Vector3.zero;
                itemTra.rotation = Quaternion.identity;
            }
        }
        item.gameObject.SetActive(active);
    }
}

/// <summary>
/// 通过FillWithTempItem 生成到列表中的物体，暂时不用的时候可以通过这个方法临时缩减列表长度
/// </summary>
/// <typeparam name="T"></typeparam>
/// <param name="goList"></param>
public static void ReleaseMostOfList<T>(List<T> goList) where T : MonoBehaviour
{
    for(int i=goList.Count -1; i> 2; i--)
    {
        var go = goList[i];
        GameObject.Destroy(go.gameObject);
        goList.RemoveAt(i);
    }
}
public static void SetActive(UnityEngine.Object obj, bool active)
{
    if(obj != null)
    {
        ((GameObject)obj).SetActive(active);
    }
    else if(obj is Component)
    {
        ((Component)obj).gameObject.SetActive(active);
    }
}
```

# 拷贝物体

```c#
/// <summary>
/// 拷贝物体
/// </summary>
/// <typeparam name="T"></typeparam>
/// <param name="parent"></param>
/// <param name="goTmp"></param>
/// <returns></returns>
public static T DuplicateItem<T>(Transform parent, MonoBehaviour goTmp)where T : MonoBehaviour
{
    T item = UnityEngine.Object.Instantiate((T)goTmp, parent, false) as T;
    Transform tran = item.transform;
    tran.localPosition = Vector3.zero;
    tran.rotation = Quaternion.identity;
    return item;
}
```

# 深度拷贝/深拷贝

```c#
/// <summary>
/// 深度拷贝组件
/// </summary>
/// <typeparam name="T"></typeparam>
/// <param name="original"></param>
/// <param name="destination"></param>
/// <returns></returns>

public static T CopyComponent<T>(T original, GameObject destination)where T : Component
{
    System.Type type = original.GetType();
    Component copy = destination.AddComponent(type);
    System.Reflection.FieldInfo[] fields = type.GetFields();
    foreach (System.Reflection.FieldInfo field in fields)
    {
        field.SetValue(copy, field.GetValue(original));
    }
    return copy as T;
}
/// <summary>
/// 深度拷贝对象，产生的额外内存消耗比对象大很多
/// </summary>
/// <typeparam name="T"></typeparam>
/// <param name="obj"></param>
/// <returns></returns>
public static T DeepClone<T>(T obj)
{
    using (MemoryStream ms = new MemoryStream())
    {
        //.Net5 以后被标记为过时，有风险
        BinaryFormatter formatter = new BinaryFormatter();
        formatter.Serialize(ms, obj);
        ms.Position = 0;
        return (T)formatter.Deserialize(ms);
    }
}

// 深拷贝方法（使用 JsonSerializer，更推荐，但不支持序列化私有字段或循环引用）
using System.Text.Json;
public static T DeepClone<T>(T obj)
{
    string json = JsonSerializer.Serialize(obj);
    return JsonSerializer.Deserialize<T>(json);
}
```



# 设置显隐

```c#
public static void SetActive(UnityEngine.Object obj, bool active)
{
    if(obj != null)
    {
        GameObject go = null;
        if (obj is GameObject)
        {
            go = (GameObject)obj;
        }
        else if(obj is Component)
        {
            go = ((Component)obj).gameObject;
        }

        if (go != null)
        {
            #if UNITY_EDITOR
            if (PrefabUtility.GetPrefabInstanceStatus(go) != PrefabInstanceStatus.NotAPrefab ||
                PrefabUtility.IsPartOfAnyPrefab(go))
                return;
            #endif

            if (go.activeSelf != active)
                go.SetActive(active);
        }
    }
}
```

# FPS的设置与显示

```csharp
using UnityEngine;
using UnityEngine.UI;

public class DebugPanel : MonoBehaviour
{
    public Text FPSText;
    public bool LockMaxFPS = false; 
    private float deltaTime = 0.0f;
    private int fpsValue = 0;
    private float timeCounter = 0f;
    
    void Start()
    {
        //设置帧率
        if(LockMaxFPS)
        {
            //利用代码禁用垂直同步VSync，否则设定帧率无效，会被覆盖为显示器的刷新率（通常是60Hz）
            //或者在 Edit > Project Settings > Quality 中，找到当前使用的质量等级（如 "High" 或 "Medium"）
            //将 VSync Count 设置为 Don't Sync。
            QualitySettings.vSyncCount = 0; 
            //将最大帧率限制为 30
            Application.targetFrameRate = 30;
        }
    }
    void Update()
    {
        deltaTime += (Time.unscaledDeltaTime - deltaTime) * 0.1f;
        timeCounter += Time.unscaledDeltaTime;
        if(timeCounter >= 0.5f)
        {
            int fpsValueNew = (int)(1.0f / deltaTime);
            if(fpsValue != fpsValueNew)
            {
                fpsValue = fpsValueNew;
                FPSText.text = fpsValue.ToString();
            }
            timeCounter = 0.0f;
        }
    }
}
```



# 常用Mono事件触发器

```c#
using UnityEngine;
using System.Collections.Generic;
using UnityEngine.Events;
public class EnableTool : MonoBehaviour
{
	public bool needEnable = true;
	public bool needDisable = false;
	public bool needUpdate = false;
	public bool needPerSecond = false;
	public float perSecondN = 1f;
	[SerializeField]
	public UnityEvent m_OnEnable=new UnityEvent();
	[SerializeField]
	public UnityEvent m_OnDisable=new UnityEvent();
	[SerializeField]
	public UnityEvent m_OnUpdate=new UnityEvent();
	[SerializeField]
	public UnityEvent m_OnUpdatePerSec=new UnityEvent();
	
	public void OnEnable()
	{
		if(!needEnable)return;
		m_OnEnable.Invoke();
	}
	public void OnDisable()
	{
		if(!needDisable)return;
		m_OnDisable.Invoke();
	}
	float secondCounter = 999f;
	void Update()
	{
		if (needUpdate)
		{
			m_OnUpdate.Invoke();

		}
		if (needPerSecond)
		{
//#if UNITY_EDITOR
            float delta = Time.deltaTime;
//#else
//            float delta = ApplicationTimer.Instance.GetDeltaTimeS();
//#endif
            secondCounter += delta;
			if (secondCounter >= this.perSecondN)
			{
				m_OnUpdatePerSec.Invoke();
				secondCounter = 0f;
			}
		}
	}
}
```

编辑器部分：

```c#
using UnityEngine;
using UnityEditor;

[CustomEditor(typeof(EnableTool))]
public class EnableToolEditor : Editor
{
	EnableTool et;
	SerializedProperty m_OnEnable;
	SerializedProperty m_OnDisable;
	SerializedProperty m_OnUpdate;
	SerializedProperty m_OnUpdatePerSec;
	void init()
	{
		et = target as EnableTool;
		m_OnEnable = serializedObject.FindProperty("m_OnEnable");
		m_OnDisable = serializedObject.FindProperty("m_OnDisable");
		m_OnUpdate = serializedObject.FindProperty("m_OnUpdate");
		m_OnUpdatePerSec = serializedObject.FindProperty("m_OnUpdatePerSec");
	}
	public override void OnInspectorGUI ()
	{
		if(null == et || null == m_OnEnable || null == m_OnDisable || null == m_OnUpdate || null == m_OnUpdatePerSec)
		{
			init();
		}
		GUILayout.Space(5f);
		EditorGUILayout.BeginHorizontal();
		if (et.needEnable)
		{
			if (GUILayout.Button("Enable",EditorStyles.toolbarButton))
			{
				et.needEnable = false;
			}
		}
		else
		{
			if (GUILayout.Button("Enable"))
			{
				et.needEnable = true;
			}
		}
		if (et.needDisable)
		{
			if (GUILayout.Button("Disable", EditorStyles.toolbarButton))
			{
				et.needDisable = false;
			}
		}
		else
		{
			if (GUILayout.Button("Disable"))
			{
				et.needDisable = true;
			}
		}
		if (et.needUpdate)
		{
			if (GUILayout.Button("Update", EditorStyles.toolbarButton))
			{
				et.needUpdate = false;
			}
		}
		else
		{
			if (GUILayout.Button("Update"))
			{
				et.needUpdate = true;
			}
		}
		if (et.needPerSecond)
		{
			if (GUILayout.Button("PerSecond", EditorStyles.toolbarButton))
			{
				et.needPerSecond = false;
			}
		}
		else
		{
			if (GUILayout.Button("PerSecond"))
			{
				et.needPerSecond = true;
			}
		}
		EditorGUILayout.EndHorizontal();
		GUILayout.Space(5f);
		serializedObject.Update();
		if(et.needEnable)
		{
			EditorGUILayout.PropertyField(m_OnEnable);
		}
		if(et.needDisable)
		{
			EditorGUILayout.PropertyField(m_OnDisable);
		}
		if(et.needUpdate)
		{
			EditorGUILayout.PropertyField(m_OnUpdate);
		}
		if(et.needPerSecond)
		{
			et.perSecondN = EditorGUILayout.FloatField("Per Second N", et.perSecondN);
			EditorGUILayout.PropertyField(m_OnUpdatePerSec);
		}
		serializedObject.ApplyModifiedProperties();
	}
}
```



# 消息监听系统

## 管理类

```c#
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ZEventManager
{
    private static ZEventManager mInstance = null;
    public static ZEventManager Instance
    {
        get
        {
            if(mInstance == null)
            {
                mInstance = new ZEventManager();
            }
            return mInstance;
        }
    }

    private List<ZEventTool> allEventTools = new List<ZEventTool>();

    public void _Reg(ZEventTool tool)
    {
        allEventTools.Add(tool);
    }
    public void _UnReg(ZEventTool tool)
    {
        allEventTools.Remove(tool);
    }

    #region PUBLIC_FUNCTION
    public void Notify(ZEventEnum.ZEventType eventType, Action<ZEventTool> callBack = null)
    {
        if (eventType == ZEventEnum.ZEventType.None)
        {
            return;
        }
        for (int i = 0; i < allEventTools.Count; i++)
        {
            var tool = allEventTools[i];
            if (tool.m_EventType == ZEventEnum.ZEventType.Any || tool.m_EventType == eventType)
            {
                tool._HandleNotify(callBack);
            }
        }
    }
    public void ClearAll()
    {
        allEventTools.Clear();
    }
    #endregion
}

```

## 枚举

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ZEventEnum
{
    public enum ZEventType
    {
        None = 0,//None Norify will work
        Any = 1,//Any Notify will work
        //Other001,
        //Other002,
        //...
        //-------------------------
        A_Part = 1000,
        A_IlynQuestEntrance,
        //-------------------------
        B_Part = 2000,
        //-------------------------
        C_Part = 3000,
        //-------------------------
        D_Part = 4000,
        //-------------------------
        E_Part = 5000,
        //-------------------------
        F_Part = 6000,
        //-------------------------
        G_Part = 7000,
        //-------------------------
        H_Part = 8000,
        //-------------------------
        I_Part = 9000,
        //-------------------------
        J_Part = 10000,
    }
}
```

## Mono组件

```c#
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using Object = UnityEngine.Object;

public class ZEventTool : MonoBehaviour
{
    public ZEventEnum.ZEventType m_EventType = ZEventEnum.ZEventType.None;
    [Header("----Show SideA or SideB----")]
    public List<Object> SideA = new List<Object>();
    public List<Object> SideB = new List<Object>();

    private Action<ZEventTool> onNotify = null;
    //You can set some Info,then onNofify() can get Info from this.
    private object Info = null;

    void Awake()
    {
        ZEventManager.Instance._Reg(this);
    }
    void OnDestroy()
    {
        ZEventManager.Instance._UnReg(this);
    }
    public void _HandleNotify(Action<ZEventTool> callBack = null)
    {
        if (callBack != null)
        {
            callBack(this);
        }
        if (onNotify != null)
        {
            onNotify(this);
        }
    }


    #region PUBLIC_FUNCTION
    public void ShowSide(bool ShowSideA)
    {
        for (int i = 0; i < SideA.Count; i++)
        {
            var obj = SideA[i];
            if (obj != null)
            {
                if(obj is GameObject)
                {
                    ((GameObject)obj).SetActive(ShowSideA);
                }
                else if (obj is Transform)
                {
                    ((Transform)obj).localScale = ShowSideA ? Vector3.one : Vector3.zero;
                }
                else if(obj is Collider)
                {
                    ((Collider)obj).enabled = ShowSideA;
                }
                else if (obj is Behaviour)
                {
                    ((Behaviour)obj).enabled = ShowSideA;
                }
            }
        }
        for (int i = 0; i < SideB.Count; i++)
        {
            var obj = SideB[i];
            if (obj != null)
            {
                if (obj is GameObject)
                {
                    ((GameObject)obj).SetActive(!ShowSideA);
                }
                else if (obj is Transform)
                {
                    ((Transform)obj).localScale = ShowSideA ? Vector3.zero : Vector3.one;
                }
                else if (obj is Collider)
                {
                    ((Collider)obj).enabled = !ShowSideA;
                }
                else if (obj is Behaviour)
                {
                    ((Behaviour)obj).enabled = !ShowSideA;
                }
            }
        }
    }

    public void SetOnNotify(Action<ZEventTool> onNotify)
    {
        this.onNotify = onNotify;
    }

    public void SetInfo(object Info)
    {
        this.Info = Info;
    }
    #endregion
}
```

# 二级分区碰撞检测

支持在场景中分多个Area区域，每个区域可配置若干个Spot点，每个点有一个逻辑碰撞盒。

以下主要是基础逻辑代码，包含进出区域触发事件功能；也包含一些项目定制代码来控制角色播放动画，可根据具体项目情况自行更改完善

```csharp
using System;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine;

public class SpotManager : MonoBehaviour
{
#if UNITY_EDITOR
    private static void TestModel(Transform tran)
    {
        if (tran != null)
        {
            GameObject go = GameObject.FindWithTag("EditorOnly");
            if (go != null)
            {
                var model = go.transform;
                model.SetParent(model.parent != tran ? tran : tran.parent, false);    
                model.localPosition = Vector3.zero;
                model.localRotation = Quaternion.identity;
                model.localScale = Vector3.one;
            }
        }
    }
#endif
    [Serializable]
    public class BaseInfo
    {
        #if UNITY_EDITOR
        [DNATools.TransformButton("Test Model", nameof(TestModel))]
        #endif
        public Transform tran;
        public float Width = 1f;//宽度
        public float Thickness = 1f;//厚度
        public float Height = 1f;//高度
        public float ForwardOffset;//前向偏移
        public float VerticalOffset;//纵向偏移
        public float HorizonOffset;//横向偏移
        // 公有方法：检测传入的Transform是否在盒子范围内
        public bool IsTransformInBounds(Vector3 targetPos, bool considerRotate)
        {
            //如果未设置坐标点，则视为无限区域, 必在区域内
            if(tran == null) return true;

            // 计算盒子的半长、半宽、半高
            Vector3 halfExtents = new Vector3(Width, Height, Thickness) * 0.5f;

            if (considerRotate)//考虑旋转，用这个方法判断, 更精确，给二级的Spot用
            {
                // 将目标点从世界坐标系转换到盒子的局部坐标系
                Vector3 localTargetPosition = tran.InverseTransformPoint(targetPos);
                // 检测目标点是否在盒子范围内
                bool isInside = Mathf.Abs(localTargetPosition.x - HorizonOffset) <= halfExtents.x &&
                                Mathf.Abs(localTargetPosition.y - VerticalOffset) <= halfExtents.y &&
                                Mathf.Abs(localTargetPosition.z - ForwardOffset) <= halfExtents.z;
                return isInside;
            }
            else//不考虑旋转，直接用盒子中心点来判断,更节省性能，给一级的Area用
            {
                // 获取盒子的中心点（考虑前向和纵向偏移）
                Vector3 center = tran.position + new Vector3(HorizonOffset,VerticalOffset,ForwardOffset);
                // 检测目标点是否在盒子范围内
                bool isInside = targetPos.x >= center.x - halfExtents.x &&
                                targetPos.x <= center.x + halfExtents.x &&
                                targetPos.y >= center.y - halfExtents.y &&
                                targetPos.y <= center.y + halfExtents.y &&
                                targetPos.z >= center.z - halfExtents.z &&
                                targetPos.z <= center.z + halfExtents.z;
                return isInside;
            }
        }
    }
    
    [Serializable]
    public class SpotInfo : BaseInfo
    {
        //0是无动画，1到100是跳舞动画，101到999是其他循环动画
        [Range(0, 1000)]
        public int AnimID;
        [Range(0, 1000)]
        //0是无事件，大于0是有事件
        public int EventID;
    }

    [Serializable]
    public class AreaInfo : BaseInfo
    {
        public List<SpotInfo> spots = new List<SpotInfo>();
    }

    [Serializable]
    public class EventInfo
    {
        public int ID;
        public UnityEngine.Events.UnityEvent OnEnter;
        public UnityEngine.Events.UnityEvent OnExit;
    }
    
    
    public StarterAssets.StarterAssetsInputsCustom mPlayer;
    public List<AreaInfo> areas = new List<AreaInfo>();
    public List<EventInfo> events = new List<EventInfo>();
    public bool ShowGizmos = true;
    
    private int CurrentIndex = -1;
    private int CurrentAreaIndex = -1;
    
    public bool isSitting { get; private set; }
    public bool canSit => CurrentIndex != -1;
    public int CurrentAnimID => CurrentIndex >= 0 ? areas[CurrentAreaIndex].spots[CurrentIndex].AnimID : 0;
    
    public DNATweenPosition mDNATweenPosition;

    public void Sit()
    {
        isSitting = true;
        mPlayer._CharacterController.enabled = false;
        mPlayer._footIK.enabled = false;
        var spot = areas[CurrentAreaIndex].spots[CurrentIndex];
        if (spot.tran != null)
        {
            mDNATweenPosition.SetTarget(mPlayer.transform);
            mDNATweenPosition.from = mPlayer.transform.position;
            mDNATweenPosition.to = spot.tran.position;
            mDNATweenPosition.PlayForwardForce();
            mPlayer.transform.rotation = spot.tran.rotation;    
        }
    }

    public void Quit()
    {
        isSitting = false;
        mPlayer._CharacterController.enabled = true;
        mPlayer._footIK.enabled = true;
    }

    void Awake()
    {
        mPlayer.mSpotManager = this;
#if UNITY_EDITOR
        GameObject go = GameObject.FindWithTag("EditorOnly");
        go?.SetActive(false);
#endif
    }

    private int BeforeIndex = -1;
    private int BeforeAreaIndex = -1;

    void FixedUpdate()
    {
        if (!isSitting)
        {
            CurrentIndex = -1;
            CurrentAreaIndex = -1;
            var pos = mPlayer.transform.position;
            for (int i = 0, len = areas.Count; i < len; i++)
            {
                var area = areas[i];
                if (!area.IsTransformInBounds(pos, false))
                {
                    continue;
                }
                CurrentAreaIndex = i;
                for (int j = 0, len2 = area.spots.Count; j < len2; j++)
                {
                    var spot = area.spots[j];
                    if (spot.IsTransformInBounds(pos, true))
                    {
                        CurrentIndex = j;
                        break;
                    }
                }
                if (CurrentAreaIndex >= 0)
                    break;
            }

            if (CurrentIndex != BeforeIndex || CurrentAreaIndex != BeforeAreaIndex)
            {
                //之前在碰撞盒, 而现在不在那个碰撞盒了, 触发退出事件
                if(BeforeIndex >= 0 && BeforeAreaIndex >= 0)
                {
                    int beforeEventID = areas[BeforeAreaIndex].spots[BeforeIndex].EventID;
                    if(beforeEventID > 0)
                        events.Find(e => e.ID == beforeEventID)?.OnExit?.Invoke();
                }
                //现在在一个碰撞盒，而之前不在这个碰撞盒, 触发进入事件
                if (CurrentIndex >= 0 && CurrentAreaIndex >= 0)
                {
                    int currentEventID = areas[CurrentAreaIndex].spots[CurrentIndex].EventID;
                    if(currentEventID > 0)
                        events.Find(e => e.ID == currentEventID)?.OnEnter?.Invoke();
                }    
            }
            BeforeIndex = CurrentIndex;
            BeforeAreaIndex = CurrentAreaIndex;
        }
    }
    
    #if UNITY_EDITOR
    void OnDrawGizmos()
    {
        if (!ShowGizmos) return;
        for (int i = 0, len = areas.Count; i < len; i++)
        {
            var area = areas[i];
            if (area.tran != null)
            {
                var posArea = area.tran.position;
                // 获取盒子的中心点（考虑前向纵向偏移,不考虑旋转）
                Vector3 centerArea = posArea + new Vector3(area.HorizonOffset, area.VerticalOffset, area.ForwardOffset);
                // 计算盒子的半长、半宽、半高
                Vector3 halfExtentsArea = new Vector3(area.Width, area.Height, area.Thickness) * 0.5f;
                // 绘制盒子的线框，一级的Area不考虑旋转
                DrawWireCube(centerArea, halfExtentsArea, Quaternion.identity,  Color.yellow, Color.yellow);
            }
            for (int j = 0, len2 = area.spots.Count; j < len2; j++)
            {
                var spot = area.spots[j];
                if (spot.tran != null)
                {
                    Gizmos.color = Color.red;
                    Vector3 pos = spot.tran.position;
                    Gizmos.DrawSphere(pos, 0.2f);
                    Vector3 posLabel = pos + Vector3.up * 0.5f;
                    UnityEditor.Handles.Label(posLabel, spot.tran.name);
                    // 获取盒子的中心点（考虑前向纵向偏移，考虑旋转）
                    Vector3 center = pos + spot.tran.forward * spot.ForwardOffset + spot.tran.up * spot.VerticalOffset + spot.tran.right * spot.HorizonOffset;
                    // 计算盒子的半长、半宽、半高
                    Vector3 halfExtents = new Vector3(spot.Width, spot.Height, spot.Thickness) * 0.5f;
                    // 绘制盒子的线框，二级的Spot考虑旋转
                    DrawWireCube(center, halfExtents, spot.tran.rotation, Color.green, Color.blue);
                }
            }
        }
    }
    
    // 辅助方法：绘制线框立方体
    private void DrawWireCube(Vector3 center, Vector3 halfExtents, Quaternion rotation, Color baseColor, Color frontcolor)
    {
        // 计算立方体的8个顶点（局部坐标系转世界坐标系）
        Vector3[] corners = new Vector3[8];
        corners[0] = center + rotation * new Vector3(-halfExtents.x, -halfExtents.y, -halfExtents.z);
        corners[1] = center + rotation * new Vector3(halfExtents.x, -halfExtents.y, -halfExtents.z);
        corners[2] = center + rotation * new Vector3(halfExtents.x, -halfExtents.y, halfExtents.z);
        corners[3] = center + rotation * new Vector3(-halfExtents.x, -halfExtents.y, halfExtents.z);
        corners[4] = center + rotation * new Vector3(-halfExtents.x, halfExtents.y, -halfExtents.z);
        corners[5] = center + rotation * new Vector3(halfExtents.x, halfExtents.y, -halfExtents.z);
        corners[6] = center + rotation * new Vector3(halfExtents.x, halfExtents.y, halfExtents.z);
        corners[7] = center + rotation * new Vector3(-halfExtents.x, halfExtents.y, halfExtents.z);

        Gizmos.color = baseColor;
        
        // 绘制立方体的12条边
        Gizmos.DrawLine(corners[0], corners[1]);
        Gizmos.DrawLine(corners[1], corners[2]);
        Gizmos.DrawLine(corners[2], corners[3]);
        Gizmos.DrawLine(corners[3], corners[0]);

        Gizmos.DrawLine(corners[4], corners[5]);
        Gizmos.DrawLine(corners[5], corners[6]);
        Gizmos.DrawLine(corners[6], corners[7]);
        Gizmos.DrawLine(corners[7], corners[4]);
        
        Gizmos.DrawLine(corners[0], corners[4]);
        Gizmos.DrawLine(corners[1], corners[5]);
        
        Gizmos.color = frontcolor;
        
        Gizmos.DrawLine(corners[2], corners[6]);
        Gizmos.DrawLine(corners[3], corners[7]);
    }
    #endif
}
```

