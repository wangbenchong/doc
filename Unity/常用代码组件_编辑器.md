# 系统菜单

## 菜单GenericMenu

功能：指定复杂的菜单，给每个选项一个预设值，而且每个选项都可以有不同的点击回调函数，预设值当参数。

```c#
using UnityEngine;
using UnityEditor;
//实现创建一个编辑器窗口，里面有一个按钮，点击后出现菜单，菜单的不同选项可让按钮变色。
public class GenericMenuExample : EditorWindow
{
    // open the window from the menu item Example -> GUI Color
    [MenuItem("Example/GUI Color")]
    static void Init()
    {
        EditorWindow window = GetWindow<GenericMenuExample>();
        window.position = new Rect(50f, 50f, 200f, 24f);
        window.Show();
    }

    // serialize field on window so its value will be saved when Unity recompiles
    [SerializeField]
    Color m_Color = Color.white;

    void OnEnable()
    {
        titleContent = new GUIContent("GUI Color");
    }

    // a method to simplify adding menu items
    void AddMenuItemForColor(GenericMenu menu, string menuPath, Color color)
    {
        // the menu item is marked as selected if it matches the current value of m_Color
        menu.AddItem(new GUIContent(menuPath), m_Color.Equals(color), OnColorSelected, color);
    }

    // the GenericMenu.MenuFunction2 event handler for when a menu item is selected
    void OnColorSelected(object color)
    {
        m_Color = (Color)color;
    }

    void OnGUI()
    {
        // set the GUI to use the color stored in m_Color
        GUI.color = m_Color;

        // display the GenericMenu when pressing a button
        if (GUILayout.Button("Select GUI Color"))
        {
            // create the menu and add items to it
            GenericMenu menu = new GenericMenu();

            // forward slashes nest menu items under submenus
            AddMenuItemForColor(menu, "RGB/Red", Color.red);
            AddMenuItemForColor(menu, "RGB/Green", Color.green);
            AddMenuItemForColor(menu, "RGB/Blue", Color.blue);

            // an empty string will create a separator at the top level
            menu.AddSeparator("");

            AddMenuItemForColor(menu, "CMYK/Cyan", Color.cyan);
            AddMenuItemForColor(menu, "CMYK/Yellow", Color.yellow);
            AddMenuItemForColor(menu, "CMYK/Magenta", Color.magenta);
            // a trailing slash will nest a separator in a submenu
            menu.AddSeparator("CMYK/");
            AddMenuItemForColor(menu, "CMYK/Black", Color.black);

            menu.AddSeparator("");

            AddMenuItemForColor(menu, "White", Color.white);

            // display the menu
            menu.ShowAsContext();
        }
    }
}
```



## 场景跳转

```c#
/// <summary>
/// 打开场景;
/// </summary>
/// <param name="path"></param>
private static bool OpenScene(string path)
{
    if (string.IsNullOrEmpty(path))
    {
        Debug.Log("the path is null or empty.");
        return false;
    }

    if (!EditorSceneManager.SaveCurrentModifiedScenesIfUserWantsTo())
    {
        Debug.Log("Please save current scence.");
        return false;
    }

    EditorSceneManager.OpenScene(path);
    return true;
}
/// <summary>
/// 游戏开始场景;
/// </summary>
[MenuItem("Z_WodCN/场景/游戏开始场景 _F5")]
private static void Launcher()
{
    OpenScene(Application.dataPath + @"/Scenes/DNOrigin.unity");
}

/// <summary>
/// 界面开发场景;
/// </summary>
[MenuItem("Z_WodCN/场景/界面编辑场景 _F6")]
private static void UI_DevAdventure()
{
    EditorApplication.isPlaying = false;
    if(!OpenScene(Application.dataPath + @"/Scenes/z_UITest.unity"))
    {
        return;
    }
    var go = GameObject.Find("2D界面挂点");
    if(go != null)
    {
        if (go.transform.childCount > 1)
        {
            var go2 = go.transform.GetChild(1);
            if (go2 != null)
            {
                EditorGUIUtility.PingObject(go2);
                Selection.activeGameObject = go2.gameObject;
            }
            else
            {
                EditorGUIUtility.PingObject(go);
                Selection.activeGameObject = go;
            }
        }
        else
        {
            EditorGUIUtility.PingObject(go);
            Selection.activeGameObject = go;
        }
    }
}
```





## 随Unity编辑器启动执行

### 编译时自动停止运行游戏

```csharp
using UnityEditor;
using UnityEditor.Compilation;

[InitializeOnLoad]
public static class InitOnload
{
    // 静态构造函数，在脚本加载时运行
    static InitOnload()
    {
        // 监听编译开始事件
        CompilationPipeline.compilationStarted += OnCompilationStarted;
    }

    // 编译开始时调用的方法
    private static void OnCompilationStarted(object obj)
    {
        // 如果当前处于播放模式，则停止游戏
        if (EditorApplication.isPlaying)
        {
            EditorApplication.isPlaying = false;
            UnityEngine.Debug.Log("编译开始，自动停止游戏运行。");
        }
    }
}
```

### 旧版Unity防止中文输入卡顿

编辑器代码如下写：
Input.imeCompositionMode = IMECompositionMode.On;
执行后，unity编辑器各处都将支持中文输入，直到重启unity才会失效。



## SVN操作

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using UnityEditor;
namespace SvnMenu
{
    public class SnvMenuEditor
    {
        private static void StopRunning()
        {
            if (EditorApplication.isPlaying)
            {
                EditorApplication.isPlaying = false;
            }
        }

        [MenuItem("SVN/Update/Update Whole Project #%&t")]
        static void SvnUpdateProject()
        {
            StopRunning();
            DoCommand("update", TryGetSvnRootDir());
        }

        [MenuItem("SVN/Update/Update Unity Project Only #%&u")]
        static void SvnUpdateUnityProject()
        {
            StopRunning();
            DoCommand("update", "./");
        }

        [MenuItem("SVN/Submit/Commit Whole Project #%t")]
        static void SvnCommitProject()
        {
            DoCommand("log", TryGetSvnRootDir());
        }

        [MenuItem("SVN/Submit/Commit Unity Project Only #%u")]
        static void SvnCommitUnityProject()
        {
            DoCommand("commit", "./");
        }

        [MenuItem("SVN/Show log/Whole Project")]
        static void SvnShowLog()
        {
            DoCommand("commit", TryGetSvnRootDir());
        }

        [MenuItem("SVN/Show log/Unity Project Only #%l")]
        static void SvnShowLogUnityProject()
        {
            DoCommand("log", "./");
        }

        [MenuItem("SVN/Revert/Revert Whole Project")]
        static void SvnRevertAll()
        {
            StopRunning();
            DoCommand("revert", TryGetSvnRootDir());
        }

        [MenuItem("SVN/Revert/Revert Unity Project Only")]
        static void SvnRevertUnityProject()
        {
            StopRunning();
            DoCommand("revert", "./");
        }

        [MenuItem("SVN/Revert/Revert GameConfig Files")]
        static void SvnRevertGameConfigFiles()
        {
            StopRunning();
            string files = Path.GetFullPath("Assets/Resources/Config/GameConfig.json") +
                "*" + Path.GetFullPath("../dev_tool/BuildConfig/GameConfig.json") +
                "*" + Path.GetFullPath("Assets/Resources/version_data.json");
            DoCommand("revert", files);
        }


        [MenuItem("Assets/SVN Show Log", false, 10003)]
        static void AssetsShowSvnLog()
        {
            if (Selection.objects.Length == 0)
            {
                return;
            }
            string path = AssetDatabase.GetAssetPath(Selection.objects[0]);
            if (string.IsNullOrEmpty(path))
            {
                return;
            }
            DoCommand("log", path);
        }
        [MenuItem("Assets/SVN Blame", false, 10004)]
        static void AssetsBlame()
        {
            if (Selection.objects.Length == 0)
            {
                return;
            }
            string path = AssetDatabase.GetAssetPath(Selection.objects[0]);
            if (string.IsNullOrEmpty(path))
            {
                return;
            }
            DoCommand("blame", path);
        }


        static void DoCommand(string cmd, string path)
        {
            System.Diagnostics.Process process = new System.Diagnostics.Process();
            System.Diagnostics.ProcessStartInfo info = new System.Diagnostics.ProcessStartInfo("tortoiseproc.exe", $" /command:{cmd} /path:{path} /closeonend:0");
            process.StartInfo = info;
            process.Start();
        }

        /// <summary>
        /// if parent dir has a sub directory named ".svn", then return parent dir; otherwise return current dir.
        /// </summary>
        /// <returns></returns>
        static string TryGetSvnRootDir()
        {
            if (Directory.Exists("./.svn"))
            {
                return "./";
            }
            if (Directory.Exists("./../.svn"))
            {
                return "./../";
            }
            if (Directory.Exists("./../../.svn"))
            {
                return "./../../";
            }
            return "./Assets";
        }
    }
}

```

# 复制粘贴

## 剪切板

```c#
/// <summary>
/// 剪切板
/// </summary>
public static string ClipBoard
{
    get
    {
        TextEditor te = new TextEditor();
        te.Paste();
        return te.text;
    }
    set
    {
        TextEditor te = new TextEditor
        {
            text = value
        };
        te.SelectAll();
        te.Copy();
    }
}
```

## 拷贝粘贴参数

```c#
private static Vector3 worldPos = Vector3.zero;
[MenuItem("GameObject/【Z_WodCN】/拷贝世界坐标", false, 9)]
static void CopyWorldPos()
{
    if (null == Selection.activeGameObject)
    {
        Debug.LogError("【拷贝世界坐标】使用方法，选择一个gameObject");
        return;
    }

    worldPos = Selection.activeGameObject.transform.position;
    Debug.Log(worldPos);
}
[MenuItem("GameObject/【Z_WodCN】/粘贴世界坐标", false, 10)]
static void ParseWorldPos()
{
    if (null == Selection.activeGameObject)
    {
        Debug.LogError("【粘贴世界坐标】使用方法，选择一个或多个gameObject");
        return;
    }
    for (int i=0;i< Selection.gameObjects.Length;i++)
    {
        var tran = Selection.gameObjects[i].transform;
        tran.position = worldPos;
    }
}
private static Vector2 sizeCopy = Vector2.one;
[MenuItem("GameObject/【Z_WodCN】/拷贝UI尺寸", false, 11)]
static void CopyUISize()
{
    if (null == Selection.activeGameObject)
    {
        Debug.LogError("【拷贝UI尺寸】使用方法，选择一个gameObject");
        return;
    }
    var w = Selection.activeGameObject.GetComponent<UIWidget>();
    if(w)
    {
        sizeCopy = w.localSize;
        Debug.Log(sizeCopy);
    }
}
[MenuItem("GameObject/【Z_WodCN】/粘贴UI尺寸", false, 12)]
static void ParseUISize()
{
    if (null == Selection.activeGameObject)
    {
        Debug.LogError("【粘贴UI宽度】使用方法，选择一个或多个gameObject");
        return;
    }
    for (int i = 0; i < Selection.gameObjects.Length; i++)
    {
        var w = Selection.gameObjects[i].GetComponent<UIWidget>();
        if(w)
        {
            w.width = (int)sizeCopy.x;
            w.height = (int)sizeCopy.y;
        }
    }
}
private static GameObject goCopy = null;
[MenuItem("GameObject/【Z_WodCN】/拷贝物体", false, 13)]
static void CopyUI()
{
    if (null == Selection.activeGameObject)
    {
        Debug.LogError("【拷贝物体】使用方法，选择一个gameObject");
        return;
    }
    goCopy = Selection.activeGameObject;
    Debug.Log(goCopy);
}
[MenuItem("GameObject/【Z_WodCN】/粘贴为子物体", false, 14)]
static void ParseUI()
{
    if (null == goCopy)
    {
        Debug.LogError("【粘贴为子物体】尚未复制");
        return;
    }
    if (null == Selection.activeGameObject)
    {
        Debug.LogError("【粘贴为子物体】使用方法，选择一个gameObject作为父物体");
        return;
    }
    var parent = Selection.activeGameObject;
    var child = GameObject.Instantiate(goCopy, parent.transform, false);
}
```

# 视觉辅助

## Gizmos文字

```c#
static GUIStyle blackStyle, whiteStyle;
/// <summary>
/// Scene下展示文字提示
/// </summary>
/// <param name="worldPos"></param>
/// <param name="text"></param>
/// <param name="isLongBlock"></param>
public static void DrawGizmosText(Vector3 worldPos, string text, bool isLongBlock = true)
{
    if(Application.isPlaying)
    {
        if(blackStyle == null)
        {
            blackStyle = new GUIStyle();
            blackStyle.normal.textColor = Color.black;
            whiteStyle = new GUIStyle();
            whiteStyle.normal.textColor = Color.white;
        }
        int index = text.IndexOf('\n');
        if(text.LastIndexOf('\n') > index)
        {
            UnityEditor.Handles.Label(worldPos, isLongBlock ? "█████████\n█████████\n█████████" : "█████\n█████\n█████", blackStyle);
        }
        else if(index >= 0)
        {
            UnityEditor.Handles.Label(worldPos, isLongBlock ? "█████████\n█████████" : "█████\n█████", blackStyle);
        }
        else
        {
            UnityEditor.Handles.Label(worldPos, isLongBlock ? "█████████" : "█████", blackStyle);
        }
        UnityEditor.Handles.Label(worldPos, text, whiteStyle);
    }
}
```



## 创建标线

组件代码：

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class AlignmentLine : MonoBehaviour
{
#if UNITY_EDITOR
    public enum EColorType
    {
        Yellow,
        Green,
        Red,
        Blue,
        White,
        Cyan,
    }
    public bool horizontal = true;
    public bool vertical = true;
    public EColorType colorType = EColorType.Yellow;
    public bool showPosOnScene = false;

    private Vector3 fromH = Vector3.zero;
    private Vector3 fromV = Vector3.zero;
    private Vector3 toH = Vector3.zero;
    private Vector3 toV = Vector3.zero;
    private const int LENGTH = 2000;
    void OnDrawGizmos()
    {
        Vector3 pos = transform.position;
        switch(colorType)
        {
            case EColorType.Yellow:
                Gizmos.color = Color.yellow;
                break;
            case EColorType.Green:
                Gizmos.color = Color.green;
                break;
            case EColorType.Red:
                Gizmos.color = Color.red;
                break;
            case EColorType.Blue:
                Gizmos.color = Color.blue;
                break;
            case EColorType.Cyan:
                Gizmos.color = Color.cyan;
                break;
            case EColorType.White:
                Gizmos.color = Color.white;
                break;
        }
        if(horizontal)
        {
            fromH = pos;
            toH = pos;
            fromH.x = pos.x - LENGTH;
            toH.x = pos.x + LENGTH;
            Gizmos.DrawLine(fromH, toH);
        }
        if(vertical)
        {
            fromV = pos;
            toV = pos;
            fromV.y = pos.y - LENGTH;
            toV.y = pos.y + LENGTH;
            Gizmos.DrawLine(fromV, toV);
        }
        if(showPosOnScene)
        {
            Vector2 v = transform.localPosition;
            UnityEditor.Handles.Label(pos, v.ToString());
        }
    }
#else
    void Awake()
    {
        DestroyImmediate(gameObject);
    }
#endif
}
```

然后再做个右键菜单：

```c#
[MenuItem ("GameObject/UI/【美术必用】标线", false, 0)]
public static void CreateAlignLine ()
{
    GameObject newChild = CreateGameObject ("标线");
    if (newChild == null) {
        return;
    }
    if (newChild.transform.parent == null) {
        return;
    }
    newChild.layer = newChild.transform.parent.gameObject.layer;
    //newChild.hideFlags = HideFlags.DontSave;
    newChild.AddComponent<AlignmentLine> ();
}
//编辑器创建gameobject通用函数，也可用于标线以外的物体创建
private static GameObject CreateGameObject (string name, Transform parent = null)
{
    if(parent == null)
    {
        Transform[] tranArr = Selection.transforms;
        if (tranArr == null || tranArr.Length == 0) {
            return null;
        }
        parent = tranArr [0];
    }
    GameObject newChild = new GameObject (name);
    Transform ChildTran = newChild.transform;
    Selection.objects = new Object[] { newChild };
    ChildTran.SetParent (parent, false);
    ChildTran.localPosition = Vector3.zero;
    ChildTran.localScale = Vector3.one;
    return newChild;
}
```



## 自定义置灰只读Attribute

[Untiy 只读属性实现_untiy 行为树锁节点 只读-CSDN博客](https://blog.csdn.net/cartzhang/article/details/53888588)

ReadOnlyAttribute.cs:

```c#
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

public class ReadOnlyAttribute : PropertyAttribute
{
}

#if UNITY_EDITOR
[CustomPropertyDrawer(typeof(ReadOnlyAttribute))]
public class ReadOnlyDrawer : PropertyDrawer
{
    public override float GetPropertyHeight(SerializedProperty property,GUIContent label)
    {
        return EditorGUI.GetPropertyHeight(property, label, true);
    }

    public override void OnGUI(Rect position,SerializedProperty property,GUIContent label)
    {
        GUI.enabled = false;
        EditorGUI.PropertyField(position, property, label, true);
        GUI.enabled = true;
    }
}
#endif
```

在monobehaviour派生脚本中这么定义变量即可置灰：

```c#
[ReadOnly]
public int numberTest = 100;
```

## 可拖拽列表ReorderableList

[Unity的Reorderable List用法_unity reorderablelist-CSDN博客](https://blog.csdn.net/alexhu2010q/article/details/122210800)

作用：具有高度定制化，即便新版unity默认的列表绘制也是可拖拽的，依然无法完全替代ReorderableList。

# 文件

## 批量修改代码行尾符号

```c#
using UnityEngine;
using UnityEditor;
using System.IO;


public class EditorMenu
{
    [MenuItem("Test/统一代码行尾符")]
    private static void SetCodeLineEnd()
    {
        if(EditorUtility.DisplayDialog("Warning", "This may take a little time, confirm doing this?","confirm", "cancel"))
        {
            DirectoryInfo dinfo = new DirectoryInfo(Application.dataPath);
            int editCount = 0, searchCount = 0;
            
            SetDirectory(dinfo, "*.cs", ref editCount, ref searchCount);
            EditorUtility.ClearProgressBar();
            if(EditorUtility.DisplayDialog("Done", "Has changed "+editCount+" files!", "ok"))
            {
                AssetDatabase.Refresh();
            }
        }
    }


    private static bool SetDirectory(DirectoryInfo dinfo, string searchPattern, ref int editCount, ref int searchCount)
    {
        if(dinfo.Exists)
        {
            FileInfo[] finfo = dinfo.GetFiles(searchPattern);
            for(int i=0; finfo != null && i < finfo.Length; i++)
            {
                System.Text.Encoding encodeing = GetFileEncode(finfo[i].FullName);
                StreamReader reader = new StreamReader(finfo[i].FullName, encodeing);
                string content = reader.ReadToEnd();
                reader.Close();
                string contentNew = content.Replace("\n", "\r\n").Replace("\r\r\n", "\r\n");
                if(contentNew.Length != content.Length)
                {
                    StreamWriter writer = new StreamWriter(finfo[i].FullName, false, encodeing);
                    writer.Write(contentNew);
                    writer.Flush();
                    writer.Close();
                    editCount++;
                }
                searchCount++;
                if(EditorUtility.DisplayCancelableProgressBar("Searching And Editing", "Searched File count: "+searchCount+", Changed file count: "+editCount, searchCount/99999f))
                {
                    return true;
                }
            }
            DirectoryInfo[] dinfoarray = dinfo.GetDirectories();
            for (int j = 0; dinfoarray != null && j < dinfoarray.Length; j++)
            {
                if (SetDirectory(dinfoarray[j], ref editCount, ref searchCount))
                {
                    return true;
                }
            }
        }
        return false;
    }


    private static System.Text.Encoding GetFileEncode(string filePath)
    {
        try
        {
            System.IO.FileStream fs = new System.IO.FileStream(filePath, System.IO.FileMode.Open, System.IO.FileAccess.Read);
            System.IO.BinaryReader br = new System.IO.BinaryReader(fs);
            byte[] buffer = br.ReadBytes(2);
            br.Close();
            fs.Close();
            if (buffer[0] >= 0xEF)
            {
                if (buffer[0] == 0xEF && buffer[1] == 0xBB)
                {
                    return System.Text.Encoding.UTF8;
                }
                else if (buffer[0] == 0xFE && buffer[1] == 0xFF)
                {
                    return System.Text.Encoding.BigEndianUnicode;
                }
                else if (buffer[0] == 0xFF && buffer[1] == 0xFE)
                {
                    return System.Text.Encoding.Unicode;
                }
            }
        }
        catch(System.Exception ex)
        {
            Debug.LogError(ex.Message);
            return System.Text.Encoding.UTF8;
        }
        return System.Text.Encoding.UTF8;
    }
}

[MenuItem("Z_WodCN/统一代码行尾符/服务端")]
private static void SetCodeLineEnd_S()
{
    if (EditorUtility.DisplayDialog("Warning", "This may take a little time, confirm doing this?", "confirm", "cancel"))
    {
        DirectoryInfo dinfo = new DirectoryInfo(Application.dataPath + "/../../project_origin/_thrift");
        int editCount = 0, searchCount = 0;

        if(!SetDirectory(dinfo, "*.thrift", ref editCount, ref searchCount))
        {
            DirectoryInfo dinfo2 = new DirectoryInfo(Application.dataPath + "/../../project_origin/src");
            if(!SetDirectory(dinfo2, "*.cpp", ref editCount, ref searchCount))
            {
                SetDirectory(dinfo2, "*.h", ref editCount, ref searchCount);
            }
        }
        EditorUtility.ClearProgressBar();
        EditorUtility.DisplayDialog("Done", "Has changed " + editCount + " server files!", "ok");
    }
}
```



## 提取fbx中的材质球和动画文件

脚本需要放在Editor文件夹内

```csharp
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using Object = UnityEngine.Object;
using UnityEditor;

public static class EditorMenu
{
    [MenuItem("Assets/fbx导出材质球")]
    static void CreateMaterialsFromFBX()
    {
        Object[] objs = Selection.objects;

        for (int i = 0, length = objs.Length; i < length; i++)
        {
            //具体到fbx的路径
            string assetPath = AssetDatabase.GetAssetPath(objs[i]);
            string materialFolder = Path.GetDirectoryName(assetPath) + "/Materials";

            // 获取assetPath下所有资源
            Object[] assets = AssetDatabase.LoadAllAssetsAtPath(assetPath);
            bool isCreate = false;
            foreach (Object item in assets)
            {
                if (typeof(Material) == item?.GetType()) //找到fbx里面的材质
                {
                    Debug.Log("找到材质文件：" + item);
                    // 如果不存在该文件夹则创建一个新的
                    if (!AssetDatabase.IsValidFolder(materialFolder))
                    {
                        AssetDatabase.CreateFolder(Path.GetDirectoryName(assetPath), "Materials");
                    }
                    string path = Path.Combine(materialFolder, item.name) + ".mat"; //提取后的名字
                    if (File.Exists(path))
                    {
                        Debug.Log("该材质已存在：" + path);

                        var assetImporter = AssetImporter.GetAtPath(assetPath);
                        var clone = AssetDatabase.LoadAssetAtPath(path, typeof(Object));
                        assetImporter.AddRemap(new AssetImporter.SourceAssetIdentifier(item), clone);
                        AssetDatabase.WriteImportSettingsIfDirty(assetPath);
                        AssetDatabase.ImportAsset(assetPath, ImportAssetOptions.ForceUpdate);
                    }
                    else
                    {
                        path = AssetDatabase.GenerateUniqueAssetPath(path);
                        string value = AssetDatabase.ExtractAsset(item, path);
                        if (string.IsNullOrEmpty(value))
                        {
                            AssetDatabase.WriteImportSettingsIfDirty(assetPath);
                            AssetDatabase.ImportAsset(assetPath, ImportAssetOptions.ForceUpdate);
                            Debug.Log("创建材质球：" + assetPath);
                            isCreate = true;
                        }
                    }
                }
            }

            AssetDatabase.Refresh();
            if (isCreate)
                Debug.Log("自动创建材质球成功，请查看文件夹：" + materialFolder);
        }
    }
    [MenuItem("Assets/fbx导出动画片段/以fbx命名")]
    static void CreateAnimFromFBX_0()
    {
        DOCreateAnimFromFBX(0);
    }
    [MenuItem("Assets/fbx导出动画片段/以动画片段命名")]
    static void CreateAnimFromFBX_1()
    {
        DOCreateAnimFromFBX(1);
    }
    [MenuItem("Assets/fbx导出动画片段/以fbx和动画片段命名")]
    static void CreateAnimFromFBX_2()
    {
        DOCreateAnimFromFBX(2);
    }
    /// <summary>
    /// fbx导出动画片段
    /// </summary>
    /// <param name="mode">0:以fbx命名 1:以动画片段命名 2:以fbx+动画片段命名</param>
    static void DOCreateAnimFromFBX(int mode)
    {
Object[] objs = Selection.objects;
        for(int i = 0,length = objs.Length; i < length; i++)
        {
            //具体到fbx的路径
            string assetPath = AssetDatabase.GetAssetPath(objs[i]);
            string animFolder = Path.GetDirectoryName(assetPath) + "/Anim";
            
            // 获取assetPath下所有资源
            Object[] assets = AssetDatabase.LoadAllAssetsAtPath(assetPath);
            bool isCreate = false;
            List<Object> animation_clip_list = new List<Object>();
            foreach (Object item in assets)
            {
                if (typeof(AnimationClip) == item?.GetType())//找到fbx里面的动画
                {
                    if(!item.name.StartsWith("__preview")){
                        Debug.Log("找到动画片段：" + item);
                        animation_clip_list.Add(item);
                    }
                }
            }
            int counter=0;
            var fileNameWithoutExtension = Path.GetFileNameWithoutExtension(assetPath);
            foreach(AnimationClip animation_clip in animation_clip_list){
                Object new_animation_clip = new AnimationClip();
                EditorUtility.CopySerialized(animation_clip, new_animation_clip);
                if(mode == 0)
                {
                    if(animation_clip_list.Count > 1)
                    {
                        new_animation_clip.name = $"{fileNameWithoutExtension}_{counter.ToString("D2")}";
                    }
                    else
                    {
                        new_animation_clip.name = fileNameWithoutExtension;
                    }
                }
                else if(mode == 1)
                {
                    new_animation_clip.name = animation_clip.name;
                }
                else if(mode == 2)
                {
                    new_animation_clip.name = $"{fileNameWithoutExtension}_{animation_clip.name}";
                }
                counter++;
                // 如果不存在该文件夹则创建一个新的
                if (!AssetDatabase.IsValidFolder(animFolder))
                {
                    AssetDatabase.CreateFolder(Path.GetDirectoryName(assetPath), "Anim");
                }
                string animation_path = Path.Combine(animFolder, new_animation_clip.name + ".anim");
                Debug.Log("创建动画文件：" + animation_path);
                AssetDatabase.CreateAsset(new_animation_clip, animation_path);
                
                isCreate = true;
            }
            AssetDatabase.Refresh();
            if (isCreate)
                Debug.Log("自动创建动画片段成功，请查看文件夹：" + animFolder);
        }
    }
    [MenuItem("Assets/fbx导出动画片段/以fbx命名", true)]
    [MenuItem("Assets/fbx导出动画片段/以动画片段命名", true)]
    [MenuItem("Assets/fbx导出动画片段/以fbx和动画片段命名", true)]
    [MenuItem("Assets/fbx导出材质球", true)]
    static bool Validate_FBX()
    {
        Object[] objs = Selection.objects;
        for (int i = 0, length = objs.Length; i < length; i++)
        {
            string assetPath = AssetDatabase.GetAssetPath(objs[i]);
            if (assetPath.ToLower().EndsWith(".fbx"))
            {
                return true;
            }
        }
        return false;
    }
}
```

**参考资料**

- [AssetImporter-AddRemap - Unity 脚本 API](https://docs.unity.cn/cn/2019.4/ScriptReference/AssetImporter.AddRemap.html)
- [Unity Editor - 一键导出模型内置材质、设置模型设置、修改Shader_unity怎么导出shader-CSDN博客](https://blog.csdn.net/qq_28299311/article/details/105943627)
- [Unity动画TA：导入fbx时直接分解出AnimationClip](https://zhuanlan.zhihu.com/p/435022514)

# Prefab预制体

## 监听Prefab的Apply

```c#
[InitializeOnLoadMethod]
static void StartInitializeOnLoadMethod () 
{
    PrefabUtility.prefabInstanceUpdated = delegate(GameObject instance) 
    {
        //prefab保存的路径
        Debug.Log(AssetDatabase.GetAssetPath(PrefabUtility.GetPrefabParent(instance)));
    };
}
```

如果需要在apply的时候自动保存到文件，可以这样写：

```c#
[InitializeOnLoadMethod]
static void Start()
{
     PrefabUtility.prefabInstanceUpdated = delegate {
        GameObject go =null;
        if(Selection.activeTransform)
        {
            go  = Selection.activeGameObject;
        }
        AssetDatabase.SaveAssets();
        if(go)
        {
            EditorApplication.delayCall = delegate {
                Selection.activeGameObject =go;
            };
        }
     };
}
```

## Prefab根据路径保存到文件

以下是ui面板在保存为prefab时的例子：

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class UIPrefabSaveTool : MonoBehaviour
{
#if UNITY_EDITOR

    public string PrefabPath;
    [ContextMenu("Select Prefab")]
    public void SelectPrefab()
    {
        if (Application.isPlaying)
        {
            return;
        }
        if (!PrefabPath.StartsWith("Assets/"))
        {
            return;
        }
        var go = UnityEditor.AssetDatabase.LoadAssetAtPath<GameObject>(PrefabPath);
        if (go != null)
        {
            UnityEditor.EditorGUIUtility.PingObject(go);
        }
    }
    [ContextMenu("Save As Prefab")]
    public void SaveAsPrefab()
    {
        if (Application.isPlaying)
        {
            return;
        }
        if (!PrefabPath.StartsWith("Assets/"))
        {
            return;
        }
        var screenSize = NGUITools.screenSize;
        if (screenSize.x != 1280 || screenSize.y != 720)
        {
            UnityEditor.EditorUtility.DisplayDialog("Error", "Game Resolution need 【1280*720】\n before save prefab!!!", "ok");
            return;
        }
        bool success;
        if (UnityEditor.EditorUtility.DisplayDialog("Message", "Confirm to Save?\n" + PrefabPath, "ok", "cancel"))
        {
            UnityEditor.PrefabUtility.SaveAsPrefabAsset(gameObject, PrefabPath, out success);
            if (success)
            {
                var go = UnityEditor.AssetDatabase.LoadAssetAtPath<GameObject>(PrefabPath);
                if (go != null)
                {
                    UnityEditor.EditorGUIUtility.PingObject(go);
                }
            }
            else
            {
                UnityEditor.EditorUtility.DisplayDialog("Error", "Fail to save file: " + PrefabPath, "ok");
            }
        }
    }
#endif
}
```



## 批量修改prefab

```c#
[MenuItem("DNTools/Panel相关/为所有面板设置节省性能的透明遮挡")]
private static void SetAllHideBlock()
{
    string fullPath = Application.dataPath + "/Art/Prefab/UGUI";
    fullPath = fullPath.Replace("/", @"\");
    string[] files = System.IO.Directory.GetFiles(fullPath, "*.prefab", SearchOption.AllDirectories);
    int filesLength = files.Length;
    int changeCount = 0;
    for (int i = 0; i < filesLength; i++)
    {
        bool changed = false;
        string assetName = files[i];
        EditorUtility.DisplayProgressBar("正在检查面板Prefab", assetName, i * 1f / filesLength);
        assetName = "Assets" + assetName.Substring(Application.dataPath.Length, assetName.Length - Application.dataPath.Length);
        GameObject objRes = AssetDatabase.LoadMainAssetAtPath(assetName) as GameObject;

        Image[] images = objRes.GetComponentsInChildren<Image>(true);
        for (int j = 0; j < images.Length; ++j)
        {
            Image current = images[j];
            if (current == null)
            {
                continue;
            }
            if (true == current.raycastTarget && 0 == current.color.a)
            {
                GameObject go = current.gameObject;
                DNAObject.DestroyImmediate(current, true);
                go.AddComponent<EmptyImageGraphic>();
                if (!changed)
                {
                    changed = true;
                    changeCount++;
                }
            }
        }
        if (changed)
        {
            EditorUtility.SetDirty(objRes);
        }
    }
    EditorUtility.ClearProgressBar();
    AssetDatabase.SaveAssets();
    EditorUtility.DisplayDialog("完毕", "共修改了" + changeCount + "个prefab", "知道了");
}
```

# 自定义代码模板

## 自定义普通CS代码模板

代码如下：

```c#
using UnityEngine;
using System.Collections;
using UnityEditor;
using UnityEditor.ProjectWindowCallback;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

public class EndNameEditAction_CreateCSharpScript : EndNameEditAction
{
    public const string AuthorFilePath = "Assets/Scripts/Z_WodCN/Scripts/UITemplate/Author.txt";
    public const string TemplateDirPath = "Assets/Scripts/Z_WodCN/Scripts/UITemplate";

    public override void Action(int instanceId, string pathName, string resourceFile)
    {
        string authorName = File.ReadAllText(AuthorFilePath);
        UnityEngine.Object o = CreateScriptAssetFromTemplate(authorName, pathName, TemplateDirPath + "/ScriptTemplate.cs");
        ProjectWindowUtil.ShowCreatedAsset(o);
    }

    internal static UnityEngine.Object CreateScriptAssetFromTemplate(string authorName, string pathName, string resourceFile)
    {
		if(authorName == "无名氏")
        {
            authorName = System.Environment.UserName;
        }
        string fullpath = Path.GetFullPath(pathName);
        string text = File.ReadAllText(resourceFile);
        string fileNamWithoutExtension = Path.GetFileNameWithoutExtension(pathName);
        text = Regex.Replace(text, "_AUTHOR_", authorName);
        text = Regex.Replace(text, "_DATE_", System.DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss"));
        text = Regex.Replace(text, "_SCRIPTNAME_", fileNamWithoutExtension);

        bool encoderShouldEmitUTF8Identifier = true;
        bool throwOnInvalidBytes = false;
        UTF8Encoding encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier, throwOnInvalidBytes);
        bool append = false;
        StreamWriter streamWriter = new StreamWriter(fullpath, append, encoding);
        streamWriter.Write(text);
        streamWriter.Close();
        AssetDatabase.ImportAsset(pathName);
        return AssetDatabase.LoadAssetAtPath(pathName, typeof(UnityEngine.Object));
    }
}
```

其中Author.txt可填写名字，默认为无名氏三个字；ScriptTemplate.cs代码如下：

```c#
/////////////////////////////////////////////////////////////////////////////////
//
//  author: _AUTHOR_
//  date:   _DATE_
//  desc:   某类
//          
//          
//          
//          
//          
/////////////////////////////////////////////////////////////////////////////////

using UnityEngine;
using System.Collections;

public class _SCRIPTNAME_
{

}
```

最后只需要写个MenuItem把菜单放出来即可调用：

```c#
[MenuItem("Assets/Z_WodCN/新建C#脚本/普通脚本", false, 10001)]
static void CreateCsharpScript()
{
    ProjectWindowUtil.StartNameEditingIfProjectWindowExists(0,
        ScriptableObject.CreateInstance<EndNameEditAction_CreateCSharpScript>(),
        _GetSelectedPathOrFallback() + "/New_CSharp.cs",
        null, "");
}
```

# 资源导入设置

## 自动设置图片格式（根据图片名称前缀）

```c#
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;

public class CustomTextureImporter : AssetPostprocessor
{
    //图片前缀
    const string CompressFlag = "UI_";
    const string CompressFlagYS = "UI_YS_";
    const string CompressFlagYH = "UI_YH_";
    const string CompressTexFlag = "UITex_";
    const static string CompressTexFlagYS = "UITex_YS_";
    const static string CompressTexFlagYH = "UITex_YH_";
    
    public void OnPostprocessTexture(Texture2D texture)
    {
        if (assetPath.StartsWith("Assets/Art/Texture/UI/"))
        {
            if (assetPath.Contains(CompressFlagYH))
            {
                //UITextureDither.DoDitherAndSave(texture);
            }
        }
    }
    public void OnPreprocessTexture()
    {
        TextureImporter importer = (TextureImporter)assetImporter;
        string texFullPath = importer.assetPath;
        string texName = System.IO.Path.GetFileName(texFullPath);


        if (texName.StartsWith("UI_"))
        {
            _DealWithUIPrefixTexture();
            return;
        }

        if (texName.QuickStartsWith("UITex_"))
        {
            _DealWithUITexPrefixTexture();
            return;
        }
    }
    
    /// <summary>
    /// UI图片处理
    /// </summary>
    private void _DealWithUIPrefixTexture()
    {
        TextureImporter importer = (TextureImporter)assetImporter;
        if (null == importer)
        {
            return;
        }
                
        importer.alphaIsTransparency = true;
        importer.wrapMode = TextureWrapMode.Clamp;
        TextureImporterPlatformSettings settings = new TextureImporterPlatformSettings
        {
            compressionQuality = (int)TextureCompressionQuality.Best,
            maxTextureSize = 1024
        };
        string texFullPath = importer.assetPath;

        if (texFullPath.Contains(CompressFlagYS))
        {//最高
            SetUITextureImporter_Best(settings, importer);
        }
        else if (texFullPath.Contains(CompressFlagYH))
        {//次高 目前只分两种，就用最高品质
            SetUITextureImporter_High(settings, importer);
        }
        else
        {//压缩
            SetUITextureImporter_Compression(settings, importer);
        }

        importer.textureType = TextureImporterType.Sprite;
        importer.spriteImportMode = SpriteImportMode.Single;
        importer.mipmapEnabled = false;
        importer.filterMode = FilterMode.Bilinear;

        System.IO.DirectoryInfo parentInfo = System.IO.Directory.GetParent(texFullPath);
        importer.spritePackingTag = parentInfo.Name;
    }

    /// <summary>
    /// UI目录下的UITex开头的文件处理
    /// </summary>
    private void _DealWithUITexPrefixTexture()
    {
        TextureImporter importer = (TextureImporter)assetImporter;
        if (null == importer)
        {
            return;
        }
        

        importer.mipmapEnabled = false;
        importer.spritePackingTag = string.Empty;
        //importer.wrapMode = TextureWrapMode.Clamp;

        bool haveAlpha = importer.DoesSourceTextureHaveAlpha();
        TextureImporterPlatformSettings settings = new TextureImporterPlatformSettings();
        importer.alphaIsTransparency = haveAlpha;
        string texFullPath = importer.assetPath;
        if (texFullPath.Contains(CompressTexFlagYS))
        {//最高
            importer.npotScale = TextureImporterNPOTScale.None;
            SetUITextureImporter_Best(settings, importer, false);
        }
        else if (texFullPath.Contains(CompressTexFlagYH))
        {//次高 目前只分两种，就用最高品质
            importer.npotScale = TextureImporterNPOTScale.None;
            SetUITextureImporter_High(settings, importer, false);
        }
        else
        {
            if (!IsAssetContainLabel(importer.assetPath, "NotSetNoptScale"))
            {
                importer.npotScale = TextureImporterNPOTScale.ToNearest;
            }
            else
            {
                importer.npotScale = TextureImporterNPOTScale.None;
            }

            //压缩
            SetUITextureImporter_Compression(settings, importer, false);
        }
    }
    
    private void SetUITextureImporter_Compression(TextureImporterPlatformSettings settings, TextureImporter importer, bool setTexSize = true)
    {
        settings.compressionQuality = (int)TextureCompressionQuality.Best;
        if (setTexSize)
        {
            settings.maxTextureSize = 1024;
        }
        bool haveAlpha = importer.DoesSourceTextureHaveAlpha();
        if (haveAlpha)
        {
            //settings.
            settings.overridden = true;
            settings.format = TextureImporterFormat.ETC2_RGBA8;
            importer.SetPlatformTextureSettings(settings);

            //Android
            settings.name = BuildTarget.Android.ToString();
            settings.overridden = true;
            settings.format = TextureImporterFormat.ETC2_RGBA8;
            importer.SetPlatformTextureSettings(settings);

            //IOS
            settings.name = "iPhone";
            settings.overridden = true;
            settings.format = TextureImporterFormat.ASTC_6x6;
            importer.SetPlatformTextureSettings(settings);
        }
        else
        {
            //settings.
            settings.overridden = true;
            settings.format = TextureImporterFormat.ETC_RGB4;
            importer.SetPlatformTextureSettings(settings);

            //Android
            settings.name = BuildTarget.Android.ToString();
            settings.overridden = true;
            settings.format = TextureImporterFormat.ETC_RGB4;
            importer.SetPlatformTextureSettings(settings);

            //IOS
            settings.name = "iPhone";
            settings.overridden = true;
            settings.format = TextureImporterFormat.ASTC_6x6;
            importer.SetPlatformTextureSettings(settings);
        }
    }

    private void SetUITextureImporter_High(TextureImporterPlatformSettings settings, TextureImporter importer, bool setTexSize = true)
    {
        settings.compressionQuality = (int)TextureCompressionQuality.Best;
        if (setTexSize)
        {
            settings.maxTextureSize = 1024;
        }
        bool haveAlpha = importer.DoesSourceTextureHaveAlpha();
        if (haveAlpha)
        {
            //settings.
            settings.overridden = true;
            settings.format = TextureImporterFormat.RGBA16;
            importer.SetPlatformTextureSettings(settings);

            //Android
            settings.name = BuildTarget.Android.ToString();
            settings.overridden = true;
            settings.format = TextureImporterFormat.RGBA16;
            importer.SetPlatformTextureSettings(settings);

            //IOS
            settings.name = "iPhone";
            settings.overridden = true;
            settings.format = TextureImporterFormat.ASTC_5x5;
            importer.SetPlatformTextureSettings(settings);
        }
        else
        {
            //settings.
            settings.overridden = true;
            settings.format = TextureImporterFormat.RGB16;
            importer.SetPlatformTextureSettings(settings);


            //Android
            settings.name = BuildTarget.Android.ToString();
            settings.overridden = true;
            settings.format = TextureImporterFormat.RGB16;
            importer.SetPlatformTextureSettings(settings);

            //IOS
            settings.name = "iPhone";
            settings.overridden = true;
            settings.format = TextureImporterFormat.ASTC_5x5;
            importer.SetPlatformTextureSettings(settings);
        }
    }

    private void SetUITextureImporter_Best(TextureImporterPlatformSettings settings, TextureImporter importer, bool setTexSize = true)
    {
        settings.compressionQuality = (int)TextureCompressionQuality.Best;
        if (setTexSize)
        {
            settings.maxTextureSize = 1024;
        }
        bool haveAlpha = importer.DoesSourceTextureHaveAlpha();
        if (haveAlpha)
        {
            //settings.
            settings.overridden = true;
            settings.format = TextureImporterFormat.RGBA32;
            importer.SetPlatformTextureSettings(settings);


            //Android
            settings.name = BuildTarget.Android.ToString();
            settings.overridden = true;
            settings.format = TextureImporterFormat.RGBA32;
            importer.SetPlatformTextureSettings(settings);

            //IOS
            settings.name = "iPhone";
            settings.overridden = true;
            settings.format = TextureImporterFormat.ASTC_4x4;
            importer.SetPlatformTextureSettings(settings);
        }
        else
        {
            //settings.
            settings.overridden = true;
            settings.format = TextureImporterFormat.RGB24;
            importer.SetPlatformTextureSettings(settings);


            //Android
            settings.name = BuildTarget.Android.ToString();
            settings.overridden = true;
            settings.format = TextureImporterFormat.RGB24;
            importer.SetPlatformTextureSettings(settings);

            //IOS
            settings.name = "iPhone";
            settings.overridden = true;
            settings.format = TextureImporterFormat.ASTC_4x4;
            importer.SetPlatformTextureSettings(settings);
        }
    }
    /// <summary>
    /// 资源是否包含标记
    /// </summary>
    /// <param name="assetPath"></param>
    /// <param name="labelFlag"></param>
    /// <returns></returns>
    public static bool IsAssetContainLabel(string assetPath, string labelFlag)
    {
        if (string.IsNullOrEmpty(labelFlag))
        {
            return false;
        }
        UnityEngine.Object dirObj = AssetDatabase.LoadAssetAtPath<UnityEngine.Object>(assetPath);
        string[] assetLabels = AssetDatabase.GetLabels(dirObj);
        bool bHas = System.Array.IndexOf(assetLabels, labelFlag) != -1;
        return bHas;
    }
}

```

## 自动设置模型、音频格式

```c#
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;
//------------模型-----------------
public class CustomModelImporter : AssetPostprocessor
{
    public void OnPreprocessModel()
    {
        ModelImporter importer = (ModelImporter)assetImporter;
        if (importer.assetPath.StartsWith("Assets/Art/Fbx/Avatar/"))
        {
            if (importer.assetPath.StartsWith("Assets/Art/Fbx/Avatar/Animations"))
            {//动作文件
                importer.animationType = ModelImporterAnimationType.Generic;
                importer.importMaterials = false;
                importer.importAnimation = true;
                importer.importBlendShapes = false;
                importer.isReadable = false;
                importer.importNormals = ModelImporterNormals.None;
            }
            else
            {//骨骼文件
                importer.animationType = ModelImporterAnimationType.Generic;
                importer.importAnimation = false;
                importer.importBlendShapes = false;
                importer.isReadable = false;
                importer.importNormals = ModelImporterNormals.None;
                //importer.animationCompression = ModelImporterAnimationCompression.Optimal;
            }
        }
        else if (importer.assetPath.StartsWith("Assets/Art/Fbx/Effect/"))
        {
            importer.isReadable = false;
            importer.meshCompression = ModelImporterMeshCompression.Medium;
            importer.optimizeMesh = true;
        }

        //法线还不能在这里去掉，导入的模型还需要光照烘培
        //string assetName = Path.GetFileNameWithoutExtension(importer.assetPath);
        //if (importer.assetPath.StartsWith("Assets/Art/Fbx/") && assetName.StartsWith("MSH_"))
        //{
        //    importer.importNormals = ModelImporterNormals.None;
        //}
    }
    public void OnPostprocessModel(GameObject go)
    {
        ModelImporter importer = (ModelImporter)assetImporter;

        string assetPath = importer.assetPath;

        if (assetPath.StartsWith("Assets/Art/Fbx/Avatar/Animations"))
        {
            //DuplicateAnimClipToAvatarExportDir(assetPath, go.name);
        }
        else if (assetPath.StartsWith("Assets/Art/Fbx/Room/RoomsFBX/"))
        {
            //DuplicateSihouetteMeshToExportDir(assetPath, go);
        }
    }

}
//------------音频-----------------
public class CustomAudioImporter : AssetPostprocessor
{
    private float musicQuality = 0.8f;
    private float soundQuality = 0.8f;
    private uint musicSampleRateOverride = 22050;

    public void OnPreprocessAudio()
    {
        AudioImporter importer = (AudioImporter)assetImporter;
        if (null == importer)
        {
            return;
        }
        string fullPath = importer.assetPath;
        string name = System.IO.Path.GetFileName(fullPath);
        if (!fullPath.StartsWith("Assets/Art/Audio"))
        {
            return;
        }
        
        //importer.forceToMono = true;//交给美术控制
        importer.preloadAudioData = true;
        importer.loadInBackground = false;
        
        if (fullPath.StartsWith("Assets/Art/Audio/Music"))
        {
            ImportMusic(importer, fullPath);
        }
        else if (fullPath.StartsWith("Assets/Art/Audio/Sound"))
        {
            AudioClipLoadType loadType = AudioClipLoadType.CompressedInMemory;
            AudioClip audioClip = AssetDatabase.LoadAssetAtPath<AudioClip>(fullPath);
            if(null != audioClip)
            {
                if (audioClip.length < AudioEditorTool.MinStreamTime)
                {
                    loadType = AudioClipLoadType.CompressedInMemory;
                }
                else
                {
                    loadType = AudioClipLoadType.Streaming;
                }
                ImportSound(importer, fullPath, loadType);
            }
            else
            {
                importer.SaveAndReimport();
            }
        }
        else
        {
            Debug.LogError("导入音频文件失败 " + fullPath);
            return;
        }
        Debug.Log("导入了音频:" + fullPath);
    }  


    private void ImportMusic(AudioImporter importer, string fullPath)
    {
        importer.preloadAudioData = true;
        importer.loadInBackground = false;

        //default settings
        AudioImporterSampleSettings defaultSetting = new AudioImporterSampleSettings
        {
            loadType = AudioClipLoadType.Streaming,
            quality = musicQuality,
            sampleRateSetting = AudioSampleRateSetting.OverrideSampleRate,
            sampleRateOverride = musicSampleRateOverride
        };
        importer.defaultSampleSettings = defaultSetting;


        importer.ClearSampleSettingOverride(BuildTarget.Android.ToString());
        importer.ClearSampleSettingOverride(BuildTarget.iOS.ToString());


        AudioImporterSampleSettings androidSetting = defaultSetting;
        androidSetting.compressionFormat = AudioCompressionFormat.Vorbis;
        importer.SetOverrideSampleSettings(BuildTarget.Android.ToString(), androidSetting);


        AudioImporterSampleSettings iosSetting = defaultSetting;
        iosSetting.compressionFormat = AudioCompressionFormat.MP3;
        importer.SetOverrideSampleSettings(BuildTarget.iOS.ToString(), iosSetting);
    }
    private void ImportSound(AudioImporter importer, string fullPath, AudioClipLoadType LoadType)
    {
        importer.preloadAudioData = true;
        importer.loadInBackground = false;

        //default settings
        AudioImporterSampleSettings defaultSetting = new AudioImporterSampleSettings
        {
            loadType = LoadType,
            quality = soundQuality,
            sampleRateSetting = AudioSampleRateSetting.OverrideSampleRate,
            sampleRateOverride = 22050
        };
        importer.defaultSampleSettings = defaultSetting;


        importer.ClearSampleSettingOverride(BuildTarget.Android.ToString());
        importer.ClearSampleSettingOverride(BuildTarget.iOS.ToString());


        AudioImporterSampleSettings androidSetting = defaultSetting;
        androidSetting.compressionFormat = AudioCompressionFormat.Vorbis;
        importer.SetOverrideSampleSettings(BuildTarget.Android.ToString(), androidSetting);


        AudioImporterSampleSettings iosSetting = defaultSetting;
        iosSetting.compressionFormat = AudioCompressionFormat.MP3;
        importer.SetOverrideSampleSettings(BuildTarget.iOS.ToString(), iosSetting);
    }
}
```

## 批量修改图片九宫格式

```c#
[MenuItem("DNTools/Panel相关/为所有UI图片根据是否做了九宫设置参数")]
private static void SetAllTextureNineStyle()
{
    string fullPath = Application.dataPath + "/Art/Texture/UI";
    fullPath = fullPath.Replace("/", @"\");
    string[] files = System.IO.Directory.GetFiles(fullPath, "*.png", SearchOption.AllDirectories);
    int filesLength = files.Length;
    int changeCount_SetFullRect = 0;
    int changeCount_SetTight = 0;
    int spriteCount = 0;
    for (int i = 0; i < filesLength; i++)
    {
        bool changed = false;
        string assetName = files[i];
        EditorUtility.DisplayProgressBar("正在为所有UI图片根据是否做了九宫设置参数", assetName, i * 1f / filesLength);
        assetName = "Assets" + assetName.Substring(Application.dataPath.Length, assetName.Length - Application.dataPath.Length);
        Sprite spr = AssetDatabase.LoadAssetAtPath<Sprite>(assetName);
        if (spr == null)
        {
            continue;
        }
        spriteCount++;
        TextureImporter importer = AssetImporter.GetAtPath(assetName) as TextureImporter;
        TextureImporterSettings tis = new TextureImporterSettings();
        importer.ReadTextureSettings(tis);
        if (spr.border != Vector4.zero)
        {
            if (tis.spriteMeshType != SpriteMeshType.FullRect)
            {
                tis.spriteMeshType = SpriteMeshType.FullRect;
                importer.SetTextureSettings(tis);
                changeCount_SetFullRect++;
                changed = true;
            }
        }
        else
        {
            if (tis.spriteMeshType != SpriteMeshType.Tight)
            {
                tis.spriteMeshType = SpriteMeshType.Tight;
                importer.SetTextureSettings(tis);
                changeCount_SetTight++;
                changed = true;
            }
        }
        if (changed)
        {
            importer.SaveAndReimport();
        }
    }

    EditorUtility.ClearProgressBar();
    EditorUtility.DisplayDialog("完毕",
        StringUtil.Format("扫描了{0}张png图，其中有{1}张是UI图，修改了{2}张图片的MeshType为FullRect, 修改了{3}张图片的MeshType为Tight",filesLength, spriteCount, changeCount_SetFullRect, changeCount_SetTight),
        "知道了");
}
```



## 导入插件时自动开启全局宏

以 IStep 插件为例，引入后自动开启了 `STARTER_ASSETS_PACKAGES_CHECKED` 宏，并且自动安装指定版本的依赖插件，是这样实现的：

```csharp
using System;
using System.Collections.Generic;
using System.IO;
using UnityEditor;
using UnityEditor.PackageManager;
using UnityEditor.PackageManager.Requests;
using UnityEngine;
using PackageInfo = UnityEditor.PackageManager.PackageInfo;

namespace StarterAssetsPackageChecker
{
    public static class PackageChecker
    {
        class PackageEntry
        {
            public string Name;
            public string Version;
        }

        [Serializable]
        class Settings
        {
            public string EditorFolderRoot = "Assets/StarterAssets/";

            public string[] PackagesToAdd = new string[]
            {
                "com.unity.cinemachine",
                "com.unity.inputsystem"
            };

            public string PackageCheckerScriptingDefine => "STARTER_ASSETS_PACKAGES_CHECKED";
        }

        static ListRequest _clientList;
        static SearchRequest _compatibleList;
        static List<PackageEntry> _packagesToAdd;

        static AddRequest[] _addRequests;
        static bool[] _installRequired;

        static Settings _settings;

        [InitializeOnLoadMethod]
        static void CheckPackage()
        {
            _settings = new Settings();
            var settingsFiles = Directory.GetFiles(Application.dataPath, "PackageCheckerSettings.json",
                SearchOption.AllDirectories);
            if (settingsFiles.Length > 0)
            {
                JsonUtility.FromJsonOverwrite(File.ReadAllText(settingsFiles[0]), _settings);
            }

            // if we dont have the scripting define, it means the check has not been done
            if (!CheckScriptingDefine(_settings.PackageCheckerScriptingDefine))
            {
                _packagesToAdd = new List<PackageEntry>();
                _clientList = null;
                _compatibleList = null;

                _packagesToAdd = new List<PackageEntry>();

                foreach (string line in _settings.PackagesToAdd)
                {
                    string[] split = line.Split('@');

                    // if no version is given, return null
                    PackageEntry entry = new PackageEntry
                        { Name = split[0], Version = split.Length > 1 ? split[1] : null };

                    _packagesToAdd.Add(entry);
                }

                // Create a file in library that is queried to see if CheckPackage() has been run already
                //-------------------核心代码---------------------
                SetScriptingDefine(_settings.PackageCheckerScriptingDefine);

                // create a list of compatible packages for current engine version
                _compatibleList = Client.SearchAll();

                while (!_compatibleList.IsCompleted)
                {
                    if (_compatibleList.Status == StatusCode.Failure || _compatibleList.Error != null)
                    {
                        if (_compatibleList.Error != null)
                        {
                            Debug.LogError(_compatibleList.Error.message);
                            break;
                        }
                    }
                }

                // create a list of packages found in the engine
                _clientList = Client.List();

                while (!_clientList.IsCompleted)
                {
                    if (_clientList.Status == StatusCode.Failure || _clientList.Error != null)
                    {
                        if (_clientList.Error != null)
                        {
                            Debug.LogError(_clientList.Error.message);
                            break;
                        }
                    }
                }

                _addRequests = new AddRequest[_packagesToAdd.Count];
                _installRequired = new bool[_packagesToAdd.Count];

                // default new packages to install = false. we will mark true after validating they're required
                for (int i = 0; i < _installRequired.Length; i++)
                {
                    _installRequired[i] = false;
                }

                // build data collections compatible packages for this project, and packages within the project
                List<PackageInfo> compatiblePackages =
                    new List<PackageInfo>();
                List<PackageInfo> clientPackages =
                    new List<PackageInfo>();

                foreach (var result in _compatibleList.Result)
                {
                    compatiblePackages.Add(result);
                }

                foreach (var result in _clientList.Result)
                {
                    clientPackages.Add(result);
                }

                // check for the latest verified package version for each package that is missing a version
                for (int i = 0; i < _packagesToAdd.Count; i++)
                {
                    // if a version number is not provided
                    if (_packagesToAdd[i].Version == null)
                    {
                        foreach (var package in compatiblePackages)
                        {
#if UNITY_2022_2_OR_NEWER
                            // if no latest verified version found, PackageChecker will just install latest release
                            if (_packagesToAdd[i].Name == package.name && package.versions.recommended != string.Empty)
                            {
                                // add latest verified version number to the packagetoadd list version
                                // so that we get the latest verified version only
                                _packagesToAdd[i].Version = package.versions.recommended;

                                // add to our install list
                                _installRequired[i] = true;

                                //Debug.Log(string.Format("Requested {0}. Latest verified compatible package found: {1}",
                                //    packagesToAdd[i].name, packagesToAdd[i].version));
                            }
                        }
#else
                            // if no latest verified version found, PackageChecker will just install latest release
                            if (_packagesToAdd[i].Name == package.name && package.versions.verified != string.Empty)
                            {
                                // add latest verified version number to the packagetoadd list version
                                // so that we get the latest verified version only
                                _packagesToAdd[i].Version = package.versions.verified;

                                // add to our install list
                                _installRequired[i] = true;

                                //Debug.Log(string.Format("Requested {0}. Latest verified compatible package found: {1}",
                                //    packagesToAdd[i].name, packagesToAdd[i].version));
                            }
                        }
#endif
                    }

                    // we don't need to catch packages that are not installed as their latest version has been collected
                    // from the campatiblelist result
                    foreach (var package in clientPackages)
                    {
                        if (_packagesToAdd[i].Name == package.name)
                        {
                            // see what version we have installed
#if UNITY_2022_2_OR_NEWER
                            switch (CompareVersion(_packagesToAdd[i].Version, package.version))
                            {
                                // latest verified is ahead of installed version
                                case 1:
                                    _installRequired[i] = EditorUtility.DisplayDialog("Confirm Package Upgrade",
                                        $"The version of \"{_packagesToAdd[i].Name}\" in this project is {package.version}. The latest verified " +
                                        $"version is {_packagesToAdd[i].Version}. Would you like to upgrade it to the latest version? (Recommended)",
                                        "Yes", "No");

                                    Debug.Log(
                                        $"<b>Package version behind</b>: {package.packageId} is behind latest verified " +
                                        $"version {package.versions.recommended}. prompting user install");
                                    break;

                                // latest verified matches installed version
                                case 0:
                                    _installRequired[i] = false;

                                    Debug.Log(
                                        $"<b>Package version match</b>: {package.packageId} matches latest verified version " +
                                        $"{package.versions.recommended}. Skipped install");
                                    break;

                                // latest verified is behind installed version
                                case -1:
                                    _installRequired[i] = EditorUtility.DisplayDialog("Confirm Package Downgrade",
                                        $"The version of \"{_packagesToAdd[i].Name}\" in this project is {package.version}. The latest verified version is {_packagesToAdd[i].Version}. " +
                                        $"{package.version} is unverified. Would you like to downgrade it to the latest verified version? " +
                                        "(Recommended)", "Yes", "No");

                                    Debug.Log(
                                        $"<b>Package version ahead</b>: {package.packageId} is newer than latest verified " +
                                        $"version {package.versions.recommended}, skipped install");
                                    break;
                            }
#else
                            switch (CompareVersion(_packagesToAdd[i].Version, package.version))
                            {
                                // latest verified is ahead of installed version
                                case 1:
                                    _installRequired[i] = EditorUtility.DisplayDialog("Confirm Package Upgrade",
                                        $"The version of \"{_packagesToAdd[i].Name}\" in this project is {package.version}. The latest verified " +
                                        $"version is {_packagesToAdd[i].Version}. Would you like to upgrade it to the latest version? (Recommended)",
                                        "Yes", "No");

                                    Debug.Log(
                                        $"<b>Package version behind</b>: {package.packageId} is behind latest verified " +
                                        $"version {package.versions.verified}. prompting user install");
                                    break;

                                // latest verified matches installed version
                                case 0:
                                    _installRequired[i] = false;

                                    Debug.Log(
                                        $"<b>Package version match</b>: {package.packageId} matches latest verified version " +
                                        $"{package.versions.verified}. Skipped install");
                                    break;

                                // latest verified is behind installed version
                                case -1:
                                    _installRequired[i] = EditorUtility.DisplayDialog("Confirm Package Downgrade",
                                        $"The version of \"{_packagesToAdd[i].Name}\" in this project is {package.version}. The latest verified version is {_packagesToAdd[i].Version}. " +
                                        $"{package.version} is unverified. Would you like to downgrade it to the latest verified version? " +
                                        "(Recommended)", "Yes", "No");

                                    Debug.Log(
                                        $"<b>Package version ahead</b>: {package.packageId} is newer than latest verified " +
                                        $"version {package.versions.verified}, skipped install");
                                    break;
                            }
#endif
                        }
                    }
                }

                // fixing bug with incompatiblity of cinemachine 2.6.14 and inputsystem 1.3.0
                string cinemachineVersion = "";
                string inputSystemVersion = "";
                int idxOfCinemachinePackage = -1;
                for (int i = 0; i < _packagesToAdd.Count; i++)
                {
                    if (_packagesToAdd[i].Name.Equals("com.unity.cinemachine"))
                    {
                        cinemachineVersion = _packagesToAdd[i].Version;
                        idxOfCinemachinePackage = i;
                    }
                    else if (_packagesToAdd[i].Name.Equals("com.unity.inputsystem"))
                    {
                        inputSystemVersion = _packagesToAdd[i].Version;
                    }
                }

                if (idxOfCinemachinePackage != -1 && cinemachineVersion == "2.6.14" && inputSystemVersion == "1.3.0")
                {
                    _packagesToAdd[idxOfCinemachinePackage].Version = "2.8.6";
                }

                // install our packages and versions
                for (int i = 0; i < _packagesToAdd.Count; i++)
                {
                    if (_installRequired[i])
                    {
                        _addRequests[i] = InstallSelectedPackage(_packagesToAdd[i].Name, _packagesToAdd[i].Version);
                    }
                }

                ReimportPackagesByKeyword();
            }
        }

        static AddRequest InstallSelectedPackage(string packageName, string packageVersion)
        {
            if (packageVersion != null)
            {
                packageName = packageName + "@" + packageVersion;
                Debug.Log($"<b>Adding package</b>: {packageName}");
            }

            AddRequest newPackage = Client.Add(packageName);

            while (!newPackage.IsCompleted)
            {
                if (newPackage.Status == StatusCode.Failure || newPackage.Error != null)
                {
                    if (newPackage.Error != null)
                    {
                        Debug.LogError(newPackage.Error.message);
                        return null;
                    }
                }
            }

            return newPackage;
        }

        static void ReimportPackagesByKeyword()
        {
            AssetDatabase.Refresh();
            AssetDatabase.ImportAsset(_settings.EditorFolderRoot, ImportAssetOptions.ImportRecursive);
        }

        public static int CompareVersion(string latestVerifiedVersion, string projectVersion)
        {
            string[] latestVersionSplit = latestVerifiedVersion.Split('.');
            string[] projectVersionSplit = projectVersion.Split('.');
            int iteratorA = 0;
            int iteratorB = 0;

            while (iteratorA < latestVersionSplit.Length || iteratorB < projectVersionSplit.Length)
            {
                int latestVerified = 0;
                int installed = 0;

                if (iteratorA < latestVersionSplit.Length)
                {
                    latestVerified = Convert.ToInt32(latestVersionSplit[iteratorA]);
                }

                if (iteratorB < projectVersionSplit.Length)
                {
                    installed = Convert.ToInt32(projectVersionSplit[iteratorB]);
                }

                // latest verified is ahead of installed version
                if (latestVerified > installed) return 1;

                // latest verified is behind installed version
                if (latestVerified < installed) return -1;

                iteratorA++;
                iteratorB++;
            }

            // if the version is the same
            return 0;
        }


        static bool CheckScriptingDefine(string scriptingDefine)
        {
            BuildTargetGroup buildTargetGroup = EditorUserBuildSettings.selectedBuildTargetGroup;
            var defines = PlayerSettings.GetScriptingDefineSymbolsForGroup(buildTargetGroup);
            return defines.Contains(scriptingDefine);
        }

    	//-------------------核心代码---------------------
        static void SetScriptingDefine(string scriptingDefine)
        {
            BuildTargetGroup buildTargetGroup = EditorUserBuildSettings.selectedBuildTargetGroup;
            var defines = PlayerSettings.GetScriptingDefineSymbolsForGroup(buildTargetGroup);
            if (!defines.Contains(scriptingDefine))
            {
                defines += $";{scriptingDefine}";
                PlayerSettings.SetScriptingDefineSymbolsForGroup(buildTargetGroup, defines);
            }
        }

        public static void RemovePackageCheckerScriptingDefine()
        {
            BuildTargetGroup buildTargetGroup = EditorUserBuildSettings.selectedBuildTargetGroup;
            var defines = PlayerSettings.GetScriptingDefineSymbolsForGroup(buildTargetGroup);
            if (defines.Contains(_settings.PackageCheckerScriptingDefine))
            {
                string newDefines = defines.Replace(_settings.PackageCheckerScriptingDefine, "");
                PlayerSettings.SetScriptingDefineSymbolsForGroup(buildTargetGroup, newDefines);
            }
        }
    }
}
```



# 查询

## 查找资源引用

下面是我自己写的FindRefEditor（如有额外需求可以用第三方插件FindReference2）

```c#
/////////////////////////////////////////////////////////////////////////////////
//
//  author: wangbenchong
//  date:   2017.12.8
//  desc:   Unity中找文件依赖关系的编辑器工具，需要Unity5.4及以上版本		
//
/////////////////////////////////////////////////////////////////////////////////
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using System.IO;
using Object = UnityEngine.Object;
using UnityEngine.UI;
using System.Text;


public class FindRefEditor : EditorWindow
{
    private static FindRefEditor editor = null;
    [MenuItem("DNATools/查找/查找资源关联 %F",false,6)]
	static void ShowWindow()
	{
		editor = GetWindow<FindRefEditor>();
        editor.titleContent = new GUIContent("找资源关联");
    }
    public enum SearchMode
    {
        DirectUseSearch,//按资源直接引用规则搜索
        MaterialDeepSearch,//按资源间接引用规则搜索，比如找使用图片的材质球被哪些prefab使用
        SearchString,//按出现的字符串搜索
    }
	private Vector2 m_vScrollMove;
    private Vector2 m_vScrollVec;
    private Color mColor = Color.green;
    private string mColorStr = "#00FF00FF";
    private bool mShowColor = true;
    private string savePath = "";
	
	Object selectFile;
    Object replaceFile;
	List<Object> selectFolders = new List<Object>();
    List<Object> results = new List<Object>();
	bool searchPrefab = true;
	bool searchScene = true;
    bool searchMaterial = false;
    SearchMode mSearchMode = SearchMode.DirectUseSearch;


    string guid = "";
    string DATAPATH = string.Empty;
	void OnEnable()
    {
        DATAPATH = Application.dataPath;
        //这句话可以让unity编辑器支持输入中文且不卡顿
        Input.imeCompositionMode = IMECompositionMode.On;
    }
	void OnGUI()
	{
        Rect rightClickRect = EditorGUILayout.BeginHorizontal();
        GUI.backgroundColor = Color.cyan;
        EditorGUILayout.HelpBox(DATAPATH + "\n资源须强制为文本；右键此区域出菜单", MessageType.None);
        GUI.backgroundColor = Color.white;
        float widthColorBar = EditorGUILayout.BeginVertical().width;
        if (mShowColor)
        {
            mColor = EditorGUILayout.ColorField(mColor, GUILayout.Width(80));
            if (GUILayout.Button("调色板",GUILayout.Width(80)))
            {
                mShowColor = false;
                this.ColorToStr();
            }
        }
        else
        {
            mColorStr = EditorGUILayout.TextField(mColorStr, GUILayout.Width(80));
            if (GUILayout.Button("调色板", GUILayout.Width(80)))
            {
                mShowColor = true;
                this.StrToColor();
            }
        }
        EditorGUILayout.EndVertical();
        EditorGUILayout.EndHorizontal();
        rightClickRect.xMax -= widthColorBar;
        if (Event.current.isMouse && Event.current.button == 1 && rightClickRect.Contains(Event.current.mousePosition))
        {
            GenericMenu menu = new GenericMenu();
            menu.AddItem(new GUIContent("Save"), false, _Save);
            menu.AddItem(new GUIContent("Load"), false, _Load);
            menu.AddItem(new GUIContent("Export Package"), false, _Export);
            menu.AddItem(new GUIContent("Clear All"), false, _ResetAll);
            menu.AddItem(new GUIContent("Clear Search Result"), false, _Reset);
            menu.AddItem(new GUIContent("Select Search Result"), false, _SelectSearchResults);
            menu.AddItem(new GUIContent("Select Search From"), false, _SelectSearchFrom);
            menu.AddItem(new GUIContent("Screen Shot"), false, _ScreenShot);
            menu.ShowAsContext();
            Event.current.Use();
        }
        EditorGUIUtility.labelWidth = 90;
        mSearchMode = (SearchMode)EditorGUILayout.EnumPopup("搜索模式", mSearchMode);
        EditorGUIUtility.labelWidth = 50;
        if (mSearchMode == SearchMode.SearchString)
        {
            guid = EditorGUILayout.TextField("字符串", guid);
        }
        else
        {
            Object obj1 = null;
            if (mSearchMode == SearchMode.DirectUseSearch)
            {
                obj1 = EditorGUILayout.ObjectField("任何文件:", selectFile, typeof(Object), true);
            }
            else if (mSearchMode == SearchMode.MaterialDeepSearch)
            {
                obj1 = EditorGUILayout.ObjectField("图片:", selectFile, typeof(Object), true);
            }
            if (GUI.changed)
            {
                selectFile = obj1;
            }
        }
        
        EditorGUIUtility.labelWidth = 35;
		EditorGUILayout.LabelField(mSearchMode == SearchMode.MaterialDeepSearch ? "搜索Prefab目录范围:" : "搜索目录范围:");
        Rect dragRect = EditorGUILayout.BeginHorizontal();
		if (GUILayout.Button("↓↓添加(Also can drag Object to me)↓↓"))
		{
			selectFolders.Add(new Object());
		}
        if(GUILayout.Button("↓↓添加Assets目录↓↓", GUILayout.Width(140)))
        {
            selectFolders.Add(AssetDatabase.LoadAssetAtPath<Object>("Assets"));
        }
        EditorGUILayout.EndHorizontal();
        Event e = Event.current;
        if (dragRect.Contains(e.mousePosition))
        {
            if (e.type == EventType.DragUpdated)
                DragAndDrop.visualMode = DragAndDropVisualMode.Generic;
            else if (e.type == EventType.DragPerform)
            {
                Object[] objs = DragAndDrop.objectReferences;
                e.Use();
                for (int i = 0; objs != null && i < objs.Length; i++)
                {
                    if (objs[i] != null)
                    {
                        selectFolders.Add(objs[i]);
                    }
                }
            }
        }
        GUILayout.Box("", GUILayout.Height(4), GUILayout.ExpandWidth(true));
        
        m_vScrollVec = EditorGUILayout.BeginScrollView(m_vScrollVec, false, false);
		for (int i = 0; i < selectFolders.Count; i++)
		{
			EditorGUILayout.BeginHorizontal();
			Object obj2 = EditorGUILayout.ObjectField("" + (i + 1), selectFolders[i], typeof(Object), true);
			if (GUI.changed)
			{
				selectFolders[i] = obj2;
			}
			if (GUILayout.Button("删除",GUILayout.Width(80)))
			{
				selectFolders.RemoveAt(i);
			}
			EditorGUILayout.EndHorizontal();
		}
        EditorGUILayout.EndScrollView();
        if (mSearchMode != SearchMode.MaterialDeepSearch)
        {
            EditorGUILayout.BeginHorizontal();
            EditorGUIUtility.labelWidth = 95;
            this.searchPrefab = EditorGUILayout.Toggle("搜索包含 Prefab", this.searchPrefab);
            EditorGUIUtility.labelWidth = 50;
            this.searchScene = EditorGUILayout.Toggle("Scene", this.searchScene);
            this.searchMaterial = EditorGUILayout.Toggle("Material", this.searchMaterial);
            EditorGUILayout.EndHorizontal();
            if (GUILayout.Button("↓↓点击执行搜索↓↓"))
            {
                DoSearch();
            }
        }
        else
        {
            if (GUILayout.Button("↓↓点击执行深度搜索↓↓\nDeep Search Refrence into Render's Material"))
            {
                DoDeepSearch();
            }
        }
        EditorGUIUtility.labelWidth = 35;
        GUILayout.Box("", GUILayout.Height(4), GUILayout.ExpandWidth(true));
		m_vScrollMove = EditorGUILayout.BeginScrollView(m_vScrollMove, false, false);
		for (int i = 0; i < results.Count; i++)
		{
			/*results[i] = */EditorGUILayout.ObjectField("" + (i + 1), results[i], typeof(Object),true);
		}

        EditorGUILayout.BeginHorizontal();
        if (results.Count > 0)
        {
            replaceFile = EditorGUILayout.ObjectField("替换为", this.replaceFile, typeof(Object), true);
            if (GUILayout.Button("替换", GUILayout.Width(60)))
            {
                DoReplace();
            }
        }
        EditorGUILayout.EndHorizontal();
        EditorGUILayout.EndScrollView();

        SearchDetail();
	}

    void DoReplace()
    {
        if (string.IsNullOrEmpty(guid))
        {
            EditorUtility.DisplayDialog("Error", "Dont know what you want to replace from", "OK");
            return;
        }
        if (replaceFile == null)
        {
            EditorUtility.DisplayDialog("Error", "Dont know what you want to replace to", "OK");
            return;
        }
        string replaceGuid = AssetDatabase.AssetPathToGUID(AssetDatabase.GetAssetPath(replaceFile));
        for (int i = 0; i < results.Count; i++)
        {
            string fileName = Application.dataPath + AssetDatabase.GetAssetPath(results[i]).Remove(0,6);
            StreamReader reader = new StreamReader(fileName, System.Text.Encoding.UTF8);
            string fileContent = reader.ReadToEnd();
            reader.Close();
            fileContent = fileContent.Replace(guid, replaceGuid);
            StreamWriter writer = new StreamWriter(fileName, false, System.Text.Encoding.UTF8);
            writer.Write(fileContent);
            writer.Flush();
            writer.Close();
        }
        AssetDatabase.Refresh();
        EditorUtility.DisplayDialog("Done", "Replace is finish,count = "+results.Count, "OK");
    }

	void DoSearch()
	{
        if (mSearchMode == SearchMode.SearchString)
        {
            if (string.IsNullOrEmpty(guid))
            {
                EditorUtility.DisplayDialog("Warning", "Please Input a string first!", "OK");
                return;
            }
        }
        else
        {

            if (selectFile != null)
            {
                guid = AssetDatabase.AssetPathToGUID(AssetDatabase.GetAssetOrScenePath(selectFile));
            }
            else
            {
                EditorUtility.DisplayDialog("Warning", "Choose a file in project first!", "OK");
                return;
            }
        }
		results.Clear();
		for (int i = 0; i < selectFolders.Count; i++)
		{
            if (selectFolders[i] == null)
            {
                continue;
            }
			string path = AssetDatabase.GetAssetOrScenePath(selectFolders[i]);
			string fullpath = Application.dataPath.Replace("Assets","") + path;
			fullpath = fullpath.Replace("/", "\\");
			DirectoryInfo dinfo = new DirectoryInfo(fullpath);
			AddFileResult(dinfo);
		}
	}
    void DoDeepSearch()
    {
        if (selectFile != null)
        {
            guid = AssetDatabase.AssetPathToGUID(AssetDatabase.GetAssetOrScenePath(selectFile));
        }
        else
        {
            EditorUtility.DisplayDialog("Warning", "Choose a file in project first!", "OK");
            return;
        }
        results.Clear();
        for (int i = 0; i < selectFolders.Count; i++)
        {
            if (selectFolders[i] == null)
            {
                continue;
            }
            string path = AssetDatabase.GetAssetOrScenePath(selectFolders[i]);
            string fullpath = Application.dataPath.Replace("Assets", "") + path;
            fullpath = fullpath.Replace("/", "\\");
            DirectoryInfo dinfo = new DirectoryInfo(fullpath);
            AddFileDeepResult(dinfo);
        }
    }
    void AddFileResult(DirectoryInfo dinfo)
	{
		if (dinfo.Exists)
		{
			FileInfo[] finfo = null;
			if (this.searchScene)
			{
				finfo = MergerArray(finfo,dinfo.GetFiles("*.unity"));
			}
			if (this.searchPrefab)
			{
				finfo = MergerArray(finfo, dinfo.GetFiles("*.prefab"));
			}
            if (this.searchMaterial)
            {
                finfo = MergerArray(finfo, dinfo.GetFiles("*.mat"));
            }
            for (int i = 0; finfo != null && i < finfo.Length; i++)
			{
                StreamReader reader = new StreamReader(finfo[i].FullName, System.Text.Encoding.UTF8);
                if (reader.ReadToEnd().Contains(guid))
				{
                    string tempstr = finfo[i].FullName.Replace("\\", "/");
                    tempstr = tempstr.Replace(Application.dataPath, "");
                    tempstr = "Assets" + tempstr;
                    Object obj = AssetDatabase.LoadAssetAtPath(tempstr, typeof(Object));
                    results.Add(obj);
				}
                reader.Close();
			}
			DirectoryInfo[] dinfoarray = dinfo.GetDirectories();
			for (int j = 0; dinfoarray != null && j < dinfoarray.Length; j++)
			{
				AddFileResult(dinfoarray[j]);
			}
		}
	}
    void AddFileDeepResult(DirectoryInfo dinfo)
    {
        if (dinfo.Exists)
        {
            FileInfo[] finfo = null;
            finfo = MergerArray(finfo, dinfo.GetFiles("*.prefab"));
            
            for (int _i = 0; finfo != null && _i < finfo.Length; _i++)
            {
                string tempstr = finfo[_i].FullName.Replace("\\", "/");
                tempstr = tempstr.Replace(Application.dataPath, "");
                tempstr = "Assets" + tempstr;
                GameObject obj = AssetDatabase.LoadAssetAtPath<GameObject>(tempstr);
                if (obj == null || results.Contains((Object)obj))
                {
                    continue;
                }
                Renderer[] rends = obj.GetComponentsInChildren<Renderer>(true);
                if (rends == null || rends.Length == 0)
                {
                    continue;
                }
                for (int i = 0; i < rends.Length; i++)
                {
                    Material[] mats = rends[i].sharedMaterials;
                    for (int j = 0; mats != null && j < mats.Length; j++)
                    {
                        string assetPath = AssetDatabase.GetAssetPath(mats[j]);
                        string fullname = Application.dataPath + assetPath.Replace("Assets/", "/");//.Substring(6);
                        if (fullname.Contains("unity_builtin_extra"))
                        {
                            continue;
                        }
                        try
                        {
                            StreamReader reader = new StreamReader(fullname, System.Text.Encoding.UTF8);
                            if (reader.ReadToEnd().Contains(guid))
                            {
                                results.Add(obj);
                                i = 65534;
                                reader.Close();
                                break;
                            }
                            reader.Close();
                        }
                        catch
                        { };
                    }
                }
            }
            DirectoryInfo[] dinfoarray = dinfo.GetDirectories();
            for (int j = 0; dinfoarray != null && j < dinfoarray.Length; j++)
            {
                AddFileDeepResult(dinfoarray[j]);
            }
        }
    }

    FileInfo[] MergerArray(FileInfo[] First, FileInfo[] Second)
	{
		if (First == null) return Second;
		if (Second == null) return First;
		FileInfo[] result = new FileInfo[First.Length + Second.Length];
		First.CopyTo(result, 0);
		Second.CopyTo(result, First.Length);
		return result;
	}

    void _Save()
    {
        savePath = EditorUtility.SaveFilePanel("choose the path you save", savePath, "", "txt");
        if (!string.IsNullOrEmpty(savePath))
        {
            StreamWriter sw = new StreamWriter(savePath, false,System.Text.Encoding.UTF8);
            this.ColorToStr();
            sw.WriteLine(this.mColorStr);
            sw.WriteLine(AssetDatabase.GetAssetPath(selectFile));
            sw.WriteLine("" + selectFolders.Count);
            for (int i = 0; i < selectFolders.Count; i++)
            {
                sw.WriteLine(AssetDatabase.GetAssetPath(selectFolders[i]));
            }
            sw.WriteLine("" + results.Count);
            for (int i = 0; i < results.Count; i++)
            {
                sw.WriteLine(AssetDatabase.GetAssetPath(results[i]));
            }
            sw.Close();
        }
    }

    void _Load()
    {
        savePath = EditorUtility.OpenFilePanel("choose the file to load", savePath, "txt");
        if (!string.IsNullOrEmpty(savePath))
        {
            int num = 0;
            StreamReader sr = new StreamReader(savePath);
            this.mColorStr = sr.ReadLine();
            this.StrToColor();
            selectFile = AssetDatabase.LoadAssetAtPath(sr.ReadLine(),typeof(Object));
            int.TryParse(sr.ReadLine(), out num);
            this.selectFolders.Clear();
            for (int i = 0; i < num; i++)
            {
                selectFolders.Add(AssetDatabase.LoadAssetAtPath(sr.ReadLine(), typeof(Object)));
            }
            int.TryParse(sr.ReadLine(), out num);
            this.results.Clear();
            for (int i = 0; i < num; i++)
            {
                results.Add(AssetDatabase.LoadAssetAtPath(sr.ReadLine(), typeof(Object)));
            }
            sr.Close();
        }
    }

    void _Export()
    {
        string tempstr = EditorUtility.SaveFilePanel("Export to", "", "", "unitypackage");
        if (!string.IsNullOrEmpty(tempstr))
        {
            string[] paths = new string[selectFolders.Count];
            for(int i=0;i<selectFolders.Count;i++)
            {
                paths[i] = AssetDatabase.GetAssetPath(selectFolders[i]);
            }
            AssetDatabase.ExportPackage(paths, tempstr, ExportPackageOptions.Recurse);
        }
    }
    void _ResetAll()
    {
        if(EditorUtility.DisplayDialog("warning", "Sure to Clear all?", "OK"))
        {
            this.results.Clear();
            searchedObject.Clear();
            selectFolders.Clear();
        }
    }
    void _Reset()
    {
        if (EditorUtility.DisplayDialog("warning", "Sure to Clear the data?", "OK"))
        {
            this.results.Clear();
            searchedObject.Clear();
        }
    }

    void _SelectSearchResults()
    {
        Selection.objects = this.results.ToArray();
    }
    void _SelectSearchFrom()
    {
        Selection.objects = this.selectFolders.ToArray();
    }
    [MenuItem("Help/截图",false,-100 )]
    static void _ScreenShot()
    {
        if (EditorApplication.isPlaying)
        {
            string pngName = "Sceenshot_" + System.DateTime.Now.ToLongTimeString().Replace(":", "_").Replace(" ", "_") + ".png";
            ScreenCapture.CaptureScreenshot(pngName, 0);
            EditorUtility.DisplayDialog("成功", "已保存到\n"+Application.dataPath.Replace("Assets","")+pngName, "知道了");
        }
        else
        {
            EditorUtility.DisplayDialog("错误", "需要场景运行时截图", "知道了");
        }
    }
    int hexCharToInt(char c)
    {
        int rt = 0;
        if (c >= 'A')
        {
            rt = (int)c - (int)'A' + 10;
        }
        else
        {
            rt = (int)c - (int)'0';
        }
        return rt;
    }

    void ColorToStr()
    {
        mColorStr = string.Format("#{0:X2}{1:X2}{2:X2}{3:X2}", (int)(255 * mColor.r), (int)(255 * mColor.g), (int)(255 * mColor.b), (int)(255 * mColor.a));
    }

    void StrToColor()
    {
        char[] tmpArr = mColorStr.ToUpper().ToCharArray();
        if (tmpArr.Length == 7 || tmpArr.Length == 9)
        {
            mColor.r = (hexCharToInt(tmpArr[1]) * 16 + hexCharToInt(tmpArr[2])) / 255f;
            mColor.g = (hexCharToInt(tmpArr[3]) * 16 + hexCharToInt(tmpArr[4])) / 255f;
            mColor.b = (hexCharToInt(tmpArr[5]) * 16 + hexCharToInt(tmpArr[6])) / 255f;
            if (tmpArr.Length == 9)
            {
                mColor.a = (hexCharToInt(tmpArr[7]) * 16 + hexCharToInt(tmpArr[8])) / 255f;
            }
            else
            {
                mColor.a = 1f;
            }
        }
    }

    #region 具体列出Prefab中所有相关子物体

    bool b_ToggleSearch = false;
    List<Object> searchedObject = new List<Object>();
    void SearchDetail()
    {
        if (!DrawHeader("具体列出Prefab中所有相关子物体(先高亮选中该prefab在Hierarchy中的实例)"))
            return;

        EditorGUI.BeginDisabledGroup(!(Selection.gameObjects.Length != 0 && Selection.activeGameObject != null));
        if (GUILayout.Button("列出相关子物体"))
        {
            GameObject go = Selection.activeGameObject;
            if (null != go)
            {
                searchedObject.Clear();
                {
                    Component[] arr = go.GetComponentsInChildren<Component>(true);
                    for(int i=0;i<arr.Length;i++)
                    {
                        Component com = arr[i];
                        string comJson = EditorJsonUtility.ToJson(com);
                        if(comJson.Contains(guid))
                        {
                            searchedObject.Add(com);
                        }
                    }
#if UNITY_2018_1_OR_NEWER
                    if(selectFile != null && PrefabUtility.GetPrefabAssetType(selectFile) == PrefabAssetType.Regular)
                    {
                        DoAllChild(go.transform);
                    }
#endif
                }
            }
        }

        if (null != searchedObject)
        {
            EditorGUILayout.LabelField("搜索结果如下：");
            EditorGUILayout.BeginVertical();
            for (int i = 0; i < searchedObject.Count; i++)
            {
                EditorGUILayout.ObjectField(searchedObject[i], typeof(Object),true);
            }
            EditorGUILayout.EndVertical();
        }
        EditorGUI.EndDisabledGroup();
    }

#if UNITY_2018_1_OR_NEWER
    private void DoAllChild(Transform tran)
    {
        for(int i=0;i<tran.childCount;i++)
        {
            Transform child = tran.GetChild(i);
            GameObject rootObj = PrefabUtility.GetCorrespondingObjectFromOriginalSource(child.gameObject);
            if(rootObj != null)
            {
                string innerPath = AssetDatabase.GetAssetPath(rootObj);
                string innerGuid = AssetDatabase.AssetPathToGUID(innerPath);
                if(!string.IsNullOrEmpty(innerGuid) && innerGuid.Equals(guid))
                {
                    searchedObject.Add(child);
                    continue;
                }
            }
            DoAllChild(child);
        }
    }
#endif

    private bool DrawHeader(string text)
    {
        if (b_ToggleSearch) text = "\u25BC" + (char)0x200a + text;
        else text = "\u25BA" + (char)0x200a + text;
        b_ToggleSearch = GUILayout.Toggle(b_ToggleSearch, text, "PreToolbar2", GUILayout.MinWidth(20f));
        return b_ToggleSearch;
    }
    #endregion

    #region 外部调用接口
    public void SetSearchAuto(Object file, string folderName)
    {
        selectFile = file;
        selectFolders.Clear();
        selectFolders.Add(AssetDatabase.LoadAssetAtPath<Object>(folderName));
        results.Clear();
        mSearchMode = SearchMode.DirectUseSearch;
        DoSearch();
    }
    //[MenuItem("Assets/查找引用我的文件（UGUI目录）", false, 10001)]
    //public static void DoSearchAuto()
    //{
    //    if(editor == null)
    //    {
    //        ShowWindow();
    //    }
    //    if (Selection.objects != null && Selection.objects.Length > 0)
    //    {
    //        editor.SetSearchAuto(Selection.objects[0], "Assets/Art/Prefab/UGUI");
    //    }
    //}
    #endregion
}
```

## 列出图片占用内存大小及所占比例

```c#
[MenuItem("DNTools/智能检查/图片检测/列出不同格式图片所占大小及比例", false, 0)]
static void ImageScaleAndPercent()
{
    long sum;
    long len_RGB32_24 = 0;
    long len_RGBA16 = 0;
    long len_OTHERS = 0;

    List<string> textureFullPathList = new List<string>();
    OnGetAllTexturesUnderPath(Application.dataPath + "/Art/Texture/UI/", textureFullPathList);

    for (int i = 0; i < textureFullPathList.Count; ++i)
    {
        string textureFullPath = textureFullPathList[i];
        TextureImporterFormat tTypes;
        long size;
        if (calculateMemorySize(textureFullPath, out size, out tTypes))
        {
            switch (tTypes)
            {
                case TextureImporterFormat.RGBA32:
                case TextureImporterFormat.RGB24:
                    len_RGB32_24 += size;
                    break;
                case TextureImporterFormat.RGBA16:
                case TextureImporterFormat.RGB16:
                    len_RGBA16 += size;
                    break;
                default:
                    len_OTHERS += size;
                    break;
            }
        }
    }
    sum = len_RGB32_24 + len_RGBA16 + len_OTHERS;
    double percent1 = (double)len_RGB32_24 / sum;
    double percent2 = (double)len_RGBA16 / sum;
    double percent3 = (double)len_OTHERS / sum;
    string s1 = percent1.ToString("0.0%");
    string s2 = percent2.ToString("0.0%");
    string s3 = percent3.ToString("0.0%");

    Debug.LogError("RGB32_24 图片,最大比例不得超过10% 目前为: " + "(" + s1 + ") " + System.Math.Round((len_RGB32_24 / 1024.0), 1) + " MB");
    Debug.LogError("RGBA16 图片:,最大比例不得超过20% 目前为: " + "(" + s2 + ") " + System.Math.Round((len_RGBA16 / 1024.0), 1) + " MB");
    Debug.LogError("OTHERS 图片, 最小比例不得低于70% 目前为: " + "(" + s3 + ") " + System.Math.Round((len_OTHERS / 1024.0), 1) + " MB");

    EditorUtility.DisplayDialog("Notice", "统计完毕,查看红色输出消息", "OK");
}

static bool calculateMemorySize(string filePath, out long size, out TextureImporterFormat tTypes)
{
    filePath = filePath.Replace("\\", "/");
    filePath = filePath.Replace(Application.dataPath, "Assets");

    tTypes = TextureImporterFormat.RGB16;
    Texture tex = AssetDatabase.LoadAssetAtPath<Texture>(filePath);
    if (tex == null)
    {
        Debug.LogError("Can't find Texture: " + filePath);
        size = 0;
        return false;
    }

    string texturePath = AssetDatabase.GetAssetPath(tex.GetInstanceID());
    TextureImporter importer = (TextureImporter)TextureImporter.GetAtPath(texturePath);
    if (importer == null)
    {
        Debug.LogError("Can't find texture importer: " + filePath);
        size = 0;
        return false;
    }

    int maxSize = 0;
    if (!importer.GetPlatformTextureSettings("Android", out maxSize, out tTypes))
    {
        TextureImporterPlatformSettings defaultSettings = importer.GetDefaultPlatformTextureSettings();
        tTypes = defaultSettings.format;
    }


    switch (tTypes)
    {
        case TextureImporterFormat.ETC_RGB4:
            size = tex.width * tex.height * (4 + 8) / 8 / 1024;      //etc1为32位压缩的6倍 + 8 alpha split
            break;
        case TextureImporterFormat.RGBA16:
            size = tex.width * tex.height * (16) / 8 / 1024;
            break;
        case TextureImporterFormat.RGBA32:
            size = tex.width * tex.height * (32) / 8 / 1024;
            break;
        case TextureImporterFormat.ETC2_RGBA8:
            size = tex.width * tex.height * 32 / 3 / 8 / 1024;      //etc2为32压缩3倍
            break;
        case TextureImporterFormat.RGB16:
            size = tex.width * tex.height * (8 + 8) / 8 / 1024;
            break;
        case TextureImporterFormat.RGB24:
            size = tex.width * tex.height * (24) / 8 / 1024;
            break;
        default:
            size = 0;
            Debug.LogError("Can't find tex format calculate type: " + tTypes + "  File: " + filePath);
            return false;
    }


    //Debug.Log(filePath + "  format: " + tTypes + "  size: " + size);

    return true;
}
private static void OnGetAllTexturesUnderPath(string fullPath, List<string> textureFullPathList)
{
    if (!System.IO.Directory.Exists(fullPath))
    {
        Debug.LogError("OnGetAllTexturesUnderPath path not exist: " + fullPath);
        return;
    }

    string[] formats = new string[] { "*.jpg", "*.png", "*.tag", "*.psd" };
    for (int i = 0; i < formats.Length; ++i)
    {
        string[] subFiles = System.IO.Directory.GetFiles(fullPath, formats[i]);
        if (subFiles != null && subFiles.Length > 0)
        {
            for (int j = 0; j < subFiles.Length; ++j)
            {
                textureFullPathList.Add(subFiles[j]);
            }
        }
    }

    string[] subDirs = System.IO.Directory.GetDirectories(fullPath);
    if (subDirs != null && subDirs.Length > 0)
    {
        for (int i = 0; i < subDirs.Length; ++i)
        {
            OnGetAllTexturesUnderPath(subDirs[i], textureFullPathList);
        }
    }
}
```

## 弹窗列出指定类型的Component

```c#
[MenuItem ("GameObject/列出选中物下面所有/BoxCollider", false, 1)]
static void GetComponentBoxCollider ()
{
    GetComponentByType<BoxCollider> ();
}

static void GetComponentByType<T> ()where T : UnityEngine.Object
{
    if (null == Selection.activeGameObject) {
        LogHelper.LogError ("使用方法，选择一个gameObject");
        return;
    }
    GameObject go = Selection.activeGameObject;
    T[] items = go.GetComponentsInChildren<T> (true);
    List<T> list = new List<T> (items);
    ObjectListWindow.Init (list);
}

public class ObjectListWindow : EditorWindow
{
    static EditorWindow mWindow;
    static List<UnityEngine.Object> mObjs;
    private Vector2 mScroll;

    public static void Init<T> (List<T> objs)where T : UnityEngine.Object
    {
        if (mWindow != null) {
            mWindow.Close ();
        }
        if (objs == null || objs.Count == 0) {
            EditorUtility.DisplayDialog ("Empty!", "Find Nothing.", "ok");
            return;
        }
        mObjs = new List<UnityEngine.Object> ();
        for (int i = 0; i < objs.Count; i++) {
            mObjs.Add (objs [i]);
        }
        mWindow = (ObjectListWindow)EditorWindow.GetWindow (typeof(ObjectListWindow), false, "ObjectList", false);
        mWindow.Show ();
    }

    void OnGUI ()
    {
        if (mWindow == null) {//ReCompiling will make mWindow null, so close window at that time
            mWindow = (ObjectListWindow)EditorWindow.GetWindow (typeof(ObjectListWindow), false, "ObjectList", false);
            mWindow.Close ();
            return;
        }
        EditorGUIUtility.labelWidth = 30;
        mScroll = EditorGUILayout.BeginScrollView (mScroll);
        for (int i = 0; i < mObjs.Count; i++) {
            EditorGUILayout.ObjectField ((i + 1).ToString (), mObjs [i], typeof(Object), true);
        }
        EditorGUILayout.EndScrollView ();
    }

    void OnDestroy ()
    {
        mWindow = null;
        if (mObjs != null) {
            mObjs.Clear ();
            mObjs = null;
        }
    }
}
```

# 
